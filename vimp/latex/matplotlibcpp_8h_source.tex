\hypertarget{matplotlibcpp_8h_source}{}\doxysection{matplotlibcpp.\+h}
\label{matplotlibcpp_8h_source}\index{include/helpers/matplotlibcpp.h@{include/helpers/matplotlibcpp.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{2 }
\DoxyCodeLine{3 \textcolor{comment}{// Python headers must be included before any system headers, since}}
\DoxyCodeLine{4 \textcolor{comment}{// they define \_POSIX\_C\_SOURCE}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <Python.h>}}
\DoxyCodeLine{6 }
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <map>}}
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include <numeric>}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <cstdint>} \textcolor{comment}{// <cstdint> requires c++11 support}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <string>} \textcolor{comment}{// std::stod}}
\DoxyCodeLine{17 }
\DoxyCodeLine{18 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#  define NPY\_NO\_DEPRECATED\_API NPY\_1\_7\_API\_VERSION}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#  include <numpy/arrayobject.h>}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#  ifdef WITH\_OPENCV}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#    include <opencv2/opencv.hpp>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#  endif }\textcolor{comment}{// WITH\_OPENCV}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{comment}{/*}}
\DoxyCodeLine{27 \textcolor{comment}{ * A bunch of constants were removed in OpenCV 4 in favour of enum classes, so}}
\DoxyCodeLine{28 \textcolor{comment}{ * define the ones we need here.}}
\DoxyCodeLine{29 \textcolor{comment}{ */}}
\DoxyCodeLine{30 \textcolor{preprocessor}{\#  if CV\_MAJOR\_VERSION > 3}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#    define CV\_BGR2RGB cv::COLOR\_BGR2RGB}}
\DoxyCodeLine{32 \textcolor{preprocessor}{\#    define CV\_BGRA2RGBA cv::COLOR\_BGRA2RGBA}}
\DoxyCodeLine{33 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{34 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// WITHOUT\_NUMPY}}
\DoxyCodeLine{35 }
\DoxyCodeLine{36 \textcolor{preprocessor}{\#if PY\_MAJOR\_VERSION >= 3}}
\DoxyCodeLine{37 \textcolor{preprocessor}{\#  define PyString\_FromString PyUnicode\_FromString}}
\DoxyCodeLine{38 \textcolor{preprocessor}{\#  define PyInt\_FromLong PyLong\_FromLong}}
\DoxyCodeLine{39 \textcolor{preprocessor}{\#  define PyString\_FromString PyUnicode\_FromString}}
\DoxyCodeLine{40 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{41 }
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{keyword}{namespace }matplotlibcpp \{}
\DoxyCodeLine{44 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{static} std::string s\_backend;}
\DoxyCodeLine{47 }
\DoxyCodeLine{48 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\_interpreter}} \{}
\DoxyCodeLine{49     PyObject* s\_python\_function\_arrow;}
\DoxyCodeLine{50     PyObject *s\_python\_function\_show;}
\DoxyCodeLine{51     PyObject *s\_python\_function\_close;}
\DoxyCodeLine{52     PyObject *s\_python\_function\_draw;}
\DoxyCodeLine{53     PyObject *s\_python\_function\_pause;}
\DoxyCodeLine{54     PyObject *s\_python\_function\_save;}
\DoxyCodeLine{55     PyObject *s\_python\_function\_figure;}
\DoxyCodeLine{56     PyObject *s\_python\_function\_fignum\_exists;}
\DoxyCodeLine{57     PyObject *s\_python\_function\_plot;}
\DoxyCodeLine{58     PyObject *s\_python\_function\_quiver;}
\DoxyCodeLine{59     PyObject* s\_python\_function\_contour;}
\DoxyCodeLine{60     PyObject *s\_python\_function\_semilogx;}
\DoxyCodeLine{61     PyObject *s\_python\_function\_semilogy;}
\DoxyCodeLine{62     PyObject *s\_python\_function\_loglog;}
\DoxyCodeLine{63     PyObject *s\_python\_function\_fill;}
\DoxyCodeLine{64     PyObject *s\_python\_function\_fill\_between;}
\DoxyCodeLine{65     PyObject *s\_python\_function\_hist;}
\DoxyCodeLine{66     PyObject *s\_python\_function\_imshow;}
\DoxyCodeLine{67     PyObject *s\_python\_function\_scatter;}
\DoxyCodeLine{68     PyObject *s\_python\_function\_boxplot;}
\DoxyCodeLine{69     PyObject *s\_python\_function\_subplot;}
\DoxyCodeLine{70     PyObject *s\_python\_function\_subplot2grid;}
\DoxyCodeLine{71     PyObject *s\_python\_function\_legend;}
\DoxyCodeLine{72     PyObject *s\_python\_function\_xlim;}
\DoxyCodeLine{73     PyObject *s\_python\_function\_ion;}
\DoxyCodeLine{74     PyObject *s\_python\_function\_ginput;}
\DoxyCodeLine{75     PyObject *s\_python\_function\_ylim;}
\DoxyCodeLine{76     PyObject *s\_python\_function\_title;}
\DoxyCodeLine{77     PyObject *s\_python\_function\_axis;}
\DoxyCodeLine{78     PyObject *s\_python\_function\_axhline;}
\DoxyCodeLine{79     PyObject *s\_python\_function\_axvline;}
\DoxyCodeLine{80     PyObject *s\_python\_function\_axvspan;}
\DoxyCodeLine{81     PyObject *s\_python\_function\_xlabel;}
\DoxyCodeLine{82     PyObject *s\_python\_function\_ylabel;}
\DoxyCodeLine{83     PyObject *s\_python\_function\_gca;}
\DoxyCodeLine{84     PyObject *s\_python\_function\_xticks;}
\DoxyCodeLine{85     PyObject *s\_python\_function\_yticks;}
\DoxyCodeLine{86     PyObject* s\_python\_function\_margins;}
\DoxyCodeLine{87     PyObject *s\_python\_function\_tick\_params;}
\DoxyCodeLine{88     PyObject *s\_python\_function\_grid;}
\DoxyCodeLine{89     PyObject* s\_python\_function\_cla;}
\DoxyCodeLine{90     PyObject *s\_python\_function\_clf;}
\DoxyCodeLine{91     PyObject *s\_python\_function\_errorbar;}
\DoxyCodeLine{92     PyObject *s\_python\_function\_annotate;}
\DoxyCodeLine{93     PyObject *s\_python\_function\_tight\_layout;}
\DoxyCodeLine{94     PyObject *s\_python\_colormap;}
\DoxyCodeLine{95     PyObject *s\_python\_empty\_tuple;}
\DoxyCodeLine{96     PyObject *s\_python\_function\_stem;}
\DoxyCodeLine{97     PyObject *s\_python\_function\_xkcd;}
\DoxyCodeLine{98     PyObject *s\_python\_function\_text;}
\DoxyCodeLine{99     PyObject *s\_python\_function\_suptitle;}
\DoxyCodeLine{100     PyObject *s\_python\_function\_bar;}
\DoxyCodeLine{101     PyObject *s\_python\_function\_barh;}
\DoxyCodeLine{102     PyObject *s\_python\_function\_colorbar;}
\DoxyCodeLine{103     PyObject *s\_python\_function\_subplots\_adjust;}
\DoxyCodeLine{104     PyObject *s\_python\_function\_rcparams;}
\DoxyCodeLine{105     PyObject *s\_python\_function\_spy;}
\DoxyCodeLine{106 }
\DoxyCodeLine{107     \textcolor{comment}{/* For now, \_interpreter is implemented as a singleton since its currently not possible to have}}
\DoxyCodeLine{108 \textcolor{comment}{       multiple independent embedded python interpreters without patching the python source code}}
\DoxyCodeLine{109 \textcolor{comment}{       or starting a separate process for each. [1]}}
\DoxyCodeLine{110 \textcolor{comment}{       Furthermore, many python objects expect that they are destructed in the same thread as they}}
\DoxyCodeLine{111 \textcolor{comment}{       were constructed. [2] So for advanced usage, a `kill()` function is provided so that library}}
\DoxyCodeLine{112 \textcolor{comment}{       users can manually ensure that the interpreter is constructed and destroyed within the}}
\DoxyCodeLine{113 \textcolor{comment}{       same thread.}}
\DoxyCodeLine{114 \textcolor{comment}{}}
\DoxyCodeLine{115 \textcolor{comment}{         1: http://bytes.com/topic/python/answers/793370-\/multiple-\/independent-\/python-\/interpreters-\/c-\/c-\/program}}
\DoxyCodeLine{116 \textcolor{comment}{         2: https://github.com/lava/matplotlib-\/cpp/pull/202\#issue-\/436220256}}
\DoxyCodeLine{117 \textcolor{comment}{       */}}
\DoxyCodeLine{118 }
\DoxyCodeLine{119     \textcolor{keyword}{static} \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\_interpreter}}\& get() \{}
\DoxyCodeLine{120         \textcolor{keywordflow}{return} interkeeper(\textcolor{keyword}{false});}
\DoxyCodeLine{121     \}}
\DoxyCodeLine{122 }
\DoxyCodeLine{123     \textcolor{keyword}{static} \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\_interpreter}}\& kill() \{}
\DoxyCodeLine{124         \textcolor{keywordflow}{return} interkeeper(\textcolor{keyword}{true});}
\DoxyCodeLine{125     \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     \textcolor{comment}{// Stores the actual singleton object referenced by `get()` and `kill()`.}}
\DoxyCodeLine{128     \textcolor{keyword}{static} \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\_interpreter}}\& interkeeper(\textcolor{keywordtype}{bool} should\_kill) \{}
\DoxyCodeLine{129         \textcolor{keyword}{static} \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\_interpreter}} ctx;}
\DoxyCodeLine{130         \textcolor{keywordflow}{if} (should\_kill)}
\DoxyCodeLine{131             ctx.\string~\_interpreter();}
\DoxyCodeLine{132         \textcolor{keywordflow}{return} ctx;}
\DoxyCodeLine{133     \}}
\DoxyCodeLine{134 }
\DoxyCodeLine{135     PyObject* safe\_import(PyObject* module, std::string fname) \{}
\DoxyCodeLine{136         PyObject* fn = PyObject\_GetAttrString(module, fname.c\_str());}
\DoxyCodeLine{137 }
\DoxyCodeLine{138         \textcolor{keywordflow}{if} (!fn)}
\DoxyCodeLine{139             \textcolor{keywordflow}{throw} std::runtime\_error(std::string(\textcolor{stringliteral}{"{}Couldn't find required function: "{}}) + fname);}
\DoxyCodeLine{140 }
\DoxyCodeLine{141         \textcolor{keywordflow}{if} (!PyFunction\_Check(fn))}
\DoxyCodeLine{142             \textcolor{keywordflow}{throw} std::runtime\_error(fname + std::string(\textcolor{stringliteral}{"{} is unexpectedly not a PyFunction."{}}));}
\DoxyCodeLine{143 }
\DoxyCodeLine{144         \textcolor{keywordflow}{return} fn;}
\DoxyCodeLine{145     \}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{keyword}{private}:}
\DoxyCodeLine{148 }
\DoxyCodeLine{149 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{150 \textcolor{preprocessor}{\#  if PY\_MAJOR\_VERSION >= 3}}
\DoxyCodeLine{151 }
\DoxyCodeLine{152     \textcolor{keywordtype}{void} *import\_numpy() \{}
\DoxyCodeLine{153         import\_array(); \textcolor{comment}{// initialize C-\/API}}
\DoxyCodeLine{154         \textcolor{keywordflow}{return} NULL;}
\DoxyCodeLine{155     \}}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{preprocessor}{\#  else}}
\DoxyCodeLine{158 }
\DoxyCodeLine{159     \textcolor{keywordtype}{void} import\_numpy() \{}
\DoxyCodeLine{160         import\_array(); \textcolor{comment}{// initialize C-\/API}}
\DoxyCodeLine{161     \}}
\DoxyCodeLine{162 }
\DoxyCodeLine{163 \textcolor{preprocessor}{\#  endif}}
\DoxyCodeLine{164 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{165 }
\DoxyCodeLine{166     \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\_interpreter}}() \{}
\DoxyCodeLine{167 }
\DoxyCodeLine{168         \textcolor{comment}{// optional but recommended}}
\DoxyCodeLine{169 \textcolor{preprocessor}{\#if PY\_MAJOR\_VERSION >= 3}}
\DoxyCodeLine{170         \textcolor{keywordtype}{wchar\_t} name[] = L\textcolor{stringliteral}{"{}plotting"{}};}
\DoxyCodeLine{171 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{172         \textcolor{keywordtype}{char} name[] = \textcolor{stringliteral}{"{}plotting"{}};}
\DoxyCodeLine{173 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{174         Py\_SetProgramName(name);}
\DoxyCodeLine{175         Py\_Initialize();}
\DoxyCodeLine{176 }
\DoxyCodeLine{177         \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} *dummy\_args[] = \{L\textcolor{stringliteral}{"{}Python"{}}, NULL\};  \textcolor{comment}{// const is needed because literals must not be modified}}
\DoxyCodeLine{178         \textcolor{keywordtype}{wchar\_t} \textcolor{keyword}{const} **argv = dummy\_args;}
\DoxyCodeLine{179         \textcolor{keywordtype}{int}             argc = \textcolor{keyword}{sizeof}(dummy\_args)/\textcolor{keyword}{sizeof}(dummy\_args[0])-\/1;}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 \textcolor{preprocessor}{\#if PY\_MAJOR\_VERSION >= 3}}
\DoxyCodeLine{182         PySys\_SetArgv(argc, \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{wchar\_t} **\textcolor{keyword}{>}(argv));}
\DoxyCodeLine{183 \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{184         PySys\_SetArgv(argc, (\textcolor{keywordtype}{char} **)(argv));}
\DoxyCodeLine{185 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{186 }
\DoxyCodeLine{187 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{188         import\_numpy(); \textcolor{comment}{// initialize numpy C-\/API}}
\DoxyCodeLine{189 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{190 }
\DoxyCodeLine{191         PyObject* matplotlibname = PyString\_FromString(\textcolor{stringliteral}{"{}matplotlib"{}});}
\DoxyCodeLine{192         PyObject* pyplotname = PyString\_FromString(\textcolor{stringliteral}{"{}matplotlib.pyplot"{}});}
\DoxyCodeLine{193         PyObject* cmname  = PyString\_FromString(\textcolor{stringliteral}{"{}matplotlib.cm"{}});}
\DoxyCodeLine{194         PyObject* pylabname  = PyString\_FromString(\textcolor{stringliteral}{"{}pylab"{}});}
\DoxyCodeLine{195         \textcolor{keywordflow}{if} (!pyplotname || !pylabname || !matplotlibname || !cmname) \{}
\DoxyCodeLine{196             \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}couldnt create string"{}});}
\DoxyCodeLine{197         \}}
\DoxyCodeLine{198 }
\DoxyCodeLine{199         PyObject* matplotlib = PyImport\_Import(matplotlibname);}
\DoxyCodeLine{200 }
\DoxyCodeLine{201         Py\_DECREF(matplotlibname);}
\DoxyCodeLine{202         \textcolor{keywordflow}{if} (!matplotlib) \{}
\DoxyCodeLine{203             PyErr\_Print();}
\DoxyCodeLine{204             \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module matplotlib!"{}});}
\DoxyCodeLine{205         \}}
\DoxyCodeLine{206 }
\DoxyCodeLine{207         \textcolor{comment}{// matplotlib.use() must be called *before* pylab, matplotlib.pyplot,}}
\DoxyCodeLine{208         \textcolor{comment}{// or matplotlib.backends is imported for the first time}}
\DoxyCodeLine{209         \textcolor{keywordflow}{if} (!s\_backend.empty()) \{}
\DoxyCodeLine{210             PyObject\_CallMethod(matplotlib, \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\textcolor{stringliteral}{"{}use"{}}), \textcolor{keyword}{const\_cast<}\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(\textcolor{stringliteral}{"{}s"{}}), s\_backend.c\_str());}
\DoxyCodeLine{211         \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213 }
\DoxyCodeLine{214 }
\DoxyCodeLine{215         PyObject* pymod = PyImport\_Import(pyplotname);}
\DoxyCodeLine{216         Py\_DECREF(pyplotname);}
\DoxyCodeLine{217         \textcolor{keywordflow}{if} (!pymod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module matplotlib.pyplot!"{}}); \}}
\DoxyCodeLine{218 }
\DoxyCodeLine{219         s\_python\_colormap = PyImport\_Import(cmname);}
\DoxyCodeLine{220         Py\_DECREF(cmname);}
\DoxyCodeLine{221         \textcolor{keywordflow}{if} (!s\_python\_colormap) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module matplotlib.cm!"{}}); \}}
\DoxyCodeLine{222 }
\DoxyCodeLine{223         PyObject* pylabmod = PyImport\_Import(pylabname);}
\DoxyCodeLine{224         Py\_DECREF(pylabname);}
\DoxyCodeLine{225         \textcolor{keywordflow}{if} (!pylabmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module pylab!"{}}); \}}
\DoxyCodeLine{226 }
\DoxyCodeLine{227         s\_python\_function\_arrow = safe\_import(pymod, \textcolor{stringliteral}{"{}arrow"{}});}
\DoxyCodeLine{228         s\_python\_function\_show = safe\_import(pymod, \textcolor{stringliteral}{"{}show"{}});}
\DoxyCodeLine{229         s\_python\_function\_close = safe\_import(pymod, \textcolor{stringliteral}{"{}close"{}});}
\DoxyCodeLine{230         s\_python\_function\_draw = safe\_import(pymod, \textcolor{stringliteral}{"{}draw"{}});}
\DoxyCodeLine{231         s\_python\_function\_pause = safe\_import(pymod, \textcolor{stringliteral}{"{}pause"{}});}
\DoxyCodeLine{232         s\_python\_function\_figure = safe\_import(pymod, \textcolor{stringliteral}{"{}figure"{}});}
\DoxyCodeLine{233         s\_python\_function\_fignum\_exists = safe\_import(pymod, \textcolor{stringliteral}{"{}fignum\_exists"{}});}
\DoxyCodeLine{234         s\_python\_function\_plot = safe\_import(pymod, \textcolor{stringliteral}{"{}plot"{}});}
\DoxyCodeLine{235         s\_python\_function\_quiver = safe\_import(pymod, \textcolor{stringliteral}{"{}quiver"{}});}
\DoxyCodeLine{236         s\_python\_function\_contour = safe\_import(pymod, \textcolor{stringliteral}{"{}contour"{}});}
\DoxyCodeLine{237         s\_python\_function\_semilogx = safe\_import(pymod, \textcolor{stringliteral}{"{}semilogx"{}});}
\DoxyCodeLine{238         s\_python\_function\_semilogy = safe\_import(pymod, \textcolor{stringliteral}{"{}semilogy"{}});}
\DoxyCodeLine{239         s\_python\_function\_loglog = safe\_import(pymod, \textcolor{stringliteral}{"{}loglog"{}});}
\DoxyCodeLine{240         s\_python\_function\_fill = safe\_import(pymod, \textcolor{stringliteral}{"{}fill"{}});}
\DoxyCodeLine{241         s\_python\_function\_fill\_between = safe\_import(pymod, \textcolor{stringliteral}{"{}fill\_between"{}});}
\DoxyCodeLine{242         s\_python\_function\_hist = safe\_import(pymod,\textcolor{stringliteral}{"{}hist"{}});}
\DoxyCodeLine{243         s\_python\_function\_scatter = safe\_import(pymod,\textcolor{stringliteral}{"{}scatter"{}});}
\DoxyCodeLine{244         s\_python\_function\_boxplot = safe\_import(pymod,\textcolor{stringliteral}{"{}boxplot"{}});}
\DoxyCodeLine{245         s\_python\_function\_subplot = safe\_import(pymod, \textcolor{stringliteral}{"{}subplot"{}});}
\DoxyCodeLine{246         s\_python\_function\_subplot2grid = safe\_import(pymod, \textcolor{stringliteral}{"{}subplot2grid"{}});}
\DoxyCodeLine{247         s\_python\_function\_legend = safe\_import(pymod, \textcolor{stringliteral}{"{}legend"{}});}
\DoxyCodeLine{248         s\_python\_function\_xlim = safe\_import(pymod, \textcolor{stringliteral}{"{}xlim"{}});}
\DoxyCodeLine{249         s\_python\_function\_ylim = safe\_import(pymod, \textcolor{stringliteral}{"{}ylim"{}});}
\DoxyCodeLine{250         s\_python\_function\_title = safe\_import(pymod, \textcolor{stringliteral}{"{}title"{}});}
\DoxyCodeLine{251         s\_python\_function\_axis = safe\_import(pymod, \textcolor{stringliteral}{"{}axis"{}});}
\DoxyCodeLine{252         s\_python\_function\_axhline = safe\_import(pymod, \textcolor{stringliteral}{"{}axhline"{}});}
\DoxyCodeLine{253         s\_python\_function\_axvline = safe\_import(pymod, \textcolor{stringliteral}{"{}axvline"{}});}
\DoxyCodeLine{254         s\_python\_function\_axvspan = safe\_import(pymod, \textcolor{stringliteral}{"{}axvspan"{}});}
\DoxyCodeLine{255         s\_python\_function\_xlabel = safe\_import(pymod, \textcolor{stringliteral}{"{}xlabel"{}});}
\DoxyCodeLine{256         s\_python\_function\_ylabel = safe\_import(pymod, \textcolor{stringliteral}{"{}ylabel"{}});}
\DoxyCodeLine{257         s\_python\_function\_gca = safe\_import(pymod, \textcolor{stringliteral}{"{}gca"{}});}
\DoxyCodeLine{258         s\_python\_function\_xticks = safe\_import(pymod, \textcolor{stringliteral}{"{}xticks"{}});}
\DoxyCodeLine{259         s\_python\_function\_yticks = safe\_import(pymod, \textcolor{stringliteral}{"{}yticks"{}});}
\DoxyCodeLine{260         s\_python\_function\_margins = safe\_import(pymod, \textcolor{stringliteral}{"{}margins"{}});}
\DoxyCodeLine{261         s\_python\_function\_tick\_params = safe\_import(pymod, \textcolor{stringliteral}{"{}tick\_params"{}});}
\DoxyCodeLine{262         s\_python\_function\_grid = safe\_import(pymod, \textcolor{stringliteral}{"{}grid"{}});}
\DoxyCodeLine{263         s\_python\_function\_ion = safe\_import(pymod, \textcolor{stringliteral}{"{}ion"{}});}
\DoxyCodeLine{264         s\_python\_function\_ginput = safe\_import(pymod, \textcolor{stringliteral}{"{}ginput"{}});}
\DoxyCodeLine{265         s\_python\_function\_save = safe\_import(pylabmod, \textcolor{stringliteral}{"{}savefig"{}});}
\DoxyCodeLine{266         s\_python\_function\_annotate = safe\_import(pymod,\textcolor{stringliteral}{"{}annotate"{}});}
\DoxyCodeLine{267         s\_python\_function\_cla = safe\_import(pymod, \textcolor{stringliteral}{"{}cla"{}});}
\DoxyCodeLine{268         s\_python\_function\_clf = safe\_import(pymod, \textcolor{stringliteral}{"{}clf"{}});}
\DoxyCodeLine{269         s\_python\_function\_errorbar = safe\_import(pymod, \textcolor{stringliteral}{"{}errorbar"{}});}
\DoxyCodeLine{270         s\_python\_function\_tight\_layout = safe\_import(pymod, \textcolor{stringliteral}{"{}tight\_layout"{}});}
\DoxyCodeLine{271         s\_python\_function\_stem = safe\_import(pymod, \textcolor{stringliteral}{"{}stem"{}});}
\DoxyCodeLine{272         s\_python\_function\_xkcd = safe\_import(pymod, \textcolor{stringliteral}{"{}xkcd"{}});}
\DoxyCodeLine{273         s\_python\_function\_text = safe\_import(pymod, \textcolor{stringliteral}{"{}text"{}});}
\DoxyCodeLine{274         s\_python\_function\_suptitle = safe\_import(pymod, \textcolor{stringliteral}{"{}suptitle"{}});}
\DoxyCodeLine{275         s\_python\_function\_bar = safe\_import(pymod,\textcolor{stringliteral}{"{}bar"{}});}
\DoxyCodeLine{276         s\_python\_function\_barh = safe\_import(pymod, \textcolor{stringliteral}{"{}barh"{}});}
\DoxyCodeLine{277         s\_python\_function\_colorbar = PyObject\_GetAttrString(pymod, \textcolor{stringliteral}{"{}colorbar"{}});}
\DoxyCodeLine{278         s\_python\_function\_subplots\_adjust = safe\_import(pymod,\textcolor{stringliteral}{"{}subplots\_adjust"{}});}
\DoxyCodeLine{279         s\_python\_function\_rcparams = PyObject\_GetAttrString(pymod, \textcolor{stringliteral}{"{}rcParams"{}});}
\DoxyCodeLine{280     s\_python\_function\_spy = PyObject\_GetAttrString(pymod, \textcolor{stringliteral}{"{}spy"{}});}
\DoxyCodeLine{281 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{282         s\_python\_function\_imshow = safe\_import(pymod, \textcolor{stringliteral}{"{}imshow"{}});}
\DoxyCodeLine{283 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{284         s\_python\_empty\_tuple = PyTuple\_New(0);}
\DoxyCodeLine{285     \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287     \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1__interpreter}{\string~\_interpreter}}() \{}
\DoxyCodeLine{288         Py\_Finalize();}
\DoxyCodeLine{289     \}}
\DoxyCodeLine{290 \};}
\DoxyCodeLine{291 }
\DoxyCodeLine{292 \} \textcolor{comment}{// end namespace detail}}
\DoxyCodeLine{293 }
\DoxyCodeLine{303 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} backend(\textcolor{keyword}{const} std::string\& name)}
\DoxyCodeLine{304 \{}
\DoxyCodeLine{305     detail::s\_backend = name;}
\DoxyCodeLine{306 \}}
\DoxyCodeLine{307 }
\DoxyCodeLine{308 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} annotate(std::string annotation, \textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} y)}
\DoxyCodeLine{309 \{}
\DoxyCodeLine{310     detail::\_interpreter::get();}
\DoxyCodeLine{311 }
\DoxyCodeLine{312     PyObject * xy = PyTuple\_New(2);}
\DoxyCodeLine{313     PyObject * str = PyString\_FromString(annotation.c\_str());}
\DoxyCodeLine{314 }
\DoxyCodeLine{315     PyTuple\_SetItem(xy,0,PyFloat\_FromDouble(x));}
\DoxyCodeLine{316     PyTuple\_SetItem(xy,1,PyFloat\_FromDouble(y));}
\DoxyCodeLine{317 }
\DoxyCodeLine{318     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{319     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}xy"{}}, xy);}
\DoxyCodeLine{320 }
\DoxyCodeLine{321     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{322     PyTuple\_SetItem(args, 0, str);}
\DoxyCodeLine{323 }
\DoxyCodeLine{324     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_annotate, args, kwargs);}
\DoxyCodeLine{325 }
\DoxyCodeLine{326     Py\_DECREF(args);}
\DoxyCodeLine{327     Py\_DECREF(kwargs);}
\DoxyCodeLine{328 }
\DoxyCodeLine{329     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{330 }
\DoxyCodeLine{331     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{332 \}}
\DoxyCodeLine{333 }
\DoxyCodeLine{334 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{335 }
\DoxyCodeLine{336 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{337 \textcolor{comment}{// Type selector for numpy array conversion}}
\DoxyCodeLine{338 \textcolor{keyword}{template} <\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}} \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_NOTYPE; \}; \textcolor{comment}{//Default}}
\DoxyCodeLine{339 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<double> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_DOUBLE; \};}
\DoxyCodeLine{340 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<float> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_FLOAT; \};}
\DoxyCodeLine{341 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<bool> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_BOOL; \};}
\DoxyCodeLine{342 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<int8\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_INT8; \};}
\DoxyCodeLine{343 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<int16\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_SHORT; \};}
\DoxyCodeLine{344 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<int32\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_INT; \};}
\DoxyCodeLine{345 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<int64\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_INT64; \};}
\DoxyCodeLine{346 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<uint8\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_UINT8; \};}
\DoxyCodeLine{347 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<uint16\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_USHORT; \};}
\DoxyCodeLine{348 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<uint32\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_ULONG; \};}
\DoxyCodeLine{349 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<uint64\_t> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_UINT64; \};}
\DoxyCodeLine{350 }
\DoxyCodeLine{351 \textcolor{comment}{// Sanity checks; comment them out or change the numpy type below if you're compiling on}}
\DoxyCodeLine{352 \textcolor{comment}{// a platform where they don't apply}}
\DoxyCodeLine{353 \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} long) == 8);}
\DoxyCodeLine{354 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<long long> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_INT64; \};}
\DoxyCodeLine{355 \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} long) == 8);}
\DoxyCodeLine{356 \textcolor{keyword}{template} <> \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1select__npy__type}{select\_npy\_type}}<unsigned long long> \{ \textcolor{keyword}{const} \textcolor{keyword}{static} NPY\_TYPES type = NPY\_UINT64; \};}
\DoxyCodeLine{357 }
\DoxyCodeLine{358 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{359 PyObject* get\_array(\textcolor{keyword}{const} std::vector<Numeric>\& v)}
\DoxyCodeLine{360 \{}
\DoxyCodeLine{361     npy\_intp vsize = v.size();}
\DoxyCodeLine{362     NPY\_TYPES type = select\_npy\_type<Numeric>::type;}
\DoxyCodeLine{363     \textcolor{keywordflow}{if} (type == NPY\_NOTYPE) \{}
\DoxyCodeLine{364         \textcolor{keywordtype}{size\_t} memsize = v.size()*\textcolor{keyword}{sizeof}(double);}
\DoxyCodeLine{365         \textcolor{keywordtype}{double}* dp = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double}*\textcolor{keyword}{>}(::malloc(memsize));}
\DoxyCodeLine{366         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i=0; i<v.size(); ++i)}
\DoxyCodeLine{367             dp[i] = v[i];}
\DoxyCodeLine{368         PyObject* varray = PyArray\_SimpleNewFromData(1, \&vsize, NPY\_DOUBLE, dp);}
\DoxyCodeLine{369         PyArray\_UpdateFlags(\textcolor{keyword}{reinterpret\_cast<}PyArrayObject*\textcolor{keyword}{>}(varray), NPY\_ARRAY\_OWNDATA);}
\DoxyCodeLine{370         \textcolor{keywordflow}{return} varray;}
\DoxyCodeLine{371     \}}
\DoxyCodeLine{372 }
\DoxyCodeLine{373     PyObject* varray = PyArray\_SimpleNewFromData(1, \&vsize, type, (\textcolor{keywordtype}{void}*)(v.data()));}
\DoxyCodeLine{374     \textcolor{keywordflow}{return} varray;}
\DoxyCodeLine{375 \}}
\DoxyCodeLine{376 }
\DoxyCodeLine{377 }
\DoxyCodeLine{378 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{379 PyObject* get\_2darray(\textcolor{keyword}{const} std::vector<::std::vector<Numeric>>\& v)}
\DoxyCodeLine{380 \{}
\DoxyCodeLine{381     \textcolor{keywordflow}{if} (v.size() < 1) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}get\_2d\_array v too small"{}});}
\DoxyCodeLine{382 }
\DoxyCodeLine{383     npy\_intp vsize[2] = \{\textcolor{keyword}{static\_cast<}npy\_intp\textcolor{keyword}{>}(v.size()),}
\DoxyCodeLine{384                          \textcolor{keyword}{static\_cast<}npy\_intp\textcolor{keyword}{>}(v[0].size())\};}
\DoxyCodeLine{385 }
\DoxyCodeLine{386     PyArrayObject *varray =}
\DoxyCodeLine{387         (PyArrayObject *)PyArray\_SimpleNew(2, vsize, NPY\_DOUBLE);}
\DoxyCodeLine{388 }
\DoxyCodeLine{389     \textcolor{keywordtype}{double} *vd\_begin = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{double} *\textcolor{keyword}{>}(PyArray\_DATA(varray));}
\DoxyCodeLine{390 }
\DoxyCodeLine{391     \textcolor{keywordflow}{for} (const ::std::vector<Numeric> \&v\_row : v) \{}
\DoxyCodeLine{392       \textcolor{keywordflow}{if} (v\_row.size() != \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{size\_t}\textcolor{keyword}{>}(vsize[1]))}
\DoxyCodeLine{393         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Missmatched array size"{}});}
\DoxyCodeLine{394       std::copy(v\_row.begin(), v\_row.end(), vd\_begin);}
\DoxyCodeLine{395       vd\_begin += vsize[1];}
\DoxyCodeLine{396     \}}
\DoxyCodeLine{397 }
\DoxyCodeLine{398     \textcolor{keywordflow}{return} \textcolor{keyword}{reinterpret\_cast<}PyObject *\textcolor{keyword}{>}(varray);}
\DoxyCodeLine{399 \}}
\DoxyCodeLine{400 }
\DoxyCodeLine{401 \textcolor{preprocessor}{\#else }\textcolor{comment}{// fallback if we don't have numpy: copy every element of the given vector}}
\DoxyCodeLine{402 }
\DoxyCodeLine{403 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{404 PyObject* get\_array(\textcolor{keyword}{const} std::vector<Numeric>\& v)}
\DoxyCodeLine{405 \{}
\DoxyCodeLine{406     PyObject* list = PyList\_New(v.size());}
\DoxyCodeLine{407     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < v.size(); ++i) \{}
\DoxyCodeLine{408         PyList\_SetItem(list, i, PyFloat\_FromDouble(v.at(i)));}
\DoxyCodeLine{409     \}}
\DoxyCodeLine{410     \textcolor{keywordflow}{return} list;}
\DoxyCodeLine{411 \}}
\DoxyCodeLine{412 }
\DoxyCodeLine{413 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// WITHOUT\_NUMPY}}
\DoxyCodeLine{414 }
\DoxyCodeLine{415 \textcolor{comment}{// sometimes, for labels and such, we need string arrays}}
\DoxyCodeLine{416 \textcolor{keyword}{inline} PyObject * get\_array(\textcolor{keyword}{const} std::vector<std::string>\& strings)}
\DoxyCodeLine{417 \{}
\DoxyCodeLine{418   PyObject* list = PyList\_New(strings.size());}
\DoxyCodeLine{419   \textcolor{keywordflow}{for} (std::size\_t i = 0; i < strings.size(); ++i) \{}
\DoxyCodeLine{420     PyList\_SetItem(list, i, PyString\_FromString(strings[i].c\_str()));}
\DoxyCodeLine{421   \}}
\DoxyCodeLine{422   \textcolor{keywordflow}{return} list;}
\DoxyCodeLine{423 \}}
\DoxyCodeLine{424 }
\DoxyCodeLine{425 \textcolor{comment}{// not all matplotlib need 2d arrays, some prefer lists of lists}}
\DoxyCodeLine{426 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{427 PyObject* get\_listlist(\textcolor{keyword}{const} std::vector<std::vector<Numeric>>\& ll)}
\DoxyCodeLine{428 \{}
\DoxyCodeLine{429   PyObject* listlist = PyList\_New(ll.size());}
\DoxyCodeLine{430   \textcolor{keywordflow}{for} (std::size\_t i = 0; i < ll.size(); ++i) \{}
\DoxyCodeLine{431     PyList\_SetItem(listlist, i, get\_array(ll[i]));}
\DoxyCodeLine{432   \}}
\DoxyCodeLine{433   \textcolor{keywordflow}{return} listlist;}
\DoxyCodeLine{434 \}}
\DoxyCodeLine{435 }
\DoxyCodeLine{436 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{437 }
\DoxyCodeLine{441 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{442 \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<Numeric> \&x, \textcolor{keyword}{const} std::vector<Numeric> \&y, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{443 \{}
\DoxyCodeLine{444     assert(x.size() == y.size());}
\DoxyCodeLine{445 }
\DoxyCodeLine{446     detail::\_interpreter::get();}
\DoxyCodeLine{447 }
\DoxyCodeLine{448     \textcolor{comment}{// using numpy arrays}}
\DoxyCodeLine{449     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{450     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{451 }
\DoxyCodeLine{452     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{453     PyObject* args = PyTuple\_New(2);}
\DoxyCodeLine{454     PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{455     PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{456 }
\DoxyCodeLine{457     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{458     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{459     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{460     \{}
\DoxyCodeLine{461         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{462     \}}
\DoxyCodeLine{463 }
\DoxyCodeLine{464     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_plot, args, kwargs);}
\DoxyCodeLine{465 }
\DoxyCodeLine{466     Py\_DECREF(args);}
\DoxyCodeLine{467     Py\_DECREF(kwargs);}
\DoxyCodeLine{468     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{469 }
\DoxyCodeLine{470     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{471 \}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \textcolor{comment}{// TODO -\/ it should be possible to make this work by implementing}}
\DoxyCodeLine{474 \textcolor{comment}{// a non-\/numpy alternative for `detail::get\_2darray()`.}}
\DoxyCodeLine{475 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{476 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{477 \textcolor{keywordtype}{void} plot\_surface(\textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&x,}
\DoxyCodeLine{478                   \textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&y,}
\DoxyCodeLine{479                   \textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&z,}
\DoxyCodeLine{480                   \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords =}
\DoxyCodeLine{481                       std::map<std::string, std::string>(),}
\DoxyCodeLine{482                   \textcolor{keyword}{const} \textcolor{keywordtype}{long} fig\_number=0)}
\DoxyCodeLine{483 \{}
\DoxyCodeLine{484   detail::\_interpreter::get();}
\DoxyCodeLine{485 }
\DoxyCodeLine{486   \textcolor{comment}{// We lazily load the modules here the first time this function is called}}
\DoxyCodeLine{487   \textcolor{comment}{// because I'm not sure that we can assume "{}matplotlib installed"{} implies}}
\DoxyCodeLine{488   \textcolor{comment}{// "{}mpl\_toolkits installed"{} on all platforms, and we don't want to require}}
\DoxyCodeLine{489   \textcolor{comment}{// it for people who don't need 3d plots.}}
\DoxyCodeLine{490   \textcolor{keyword}{static} PyObject *mpl\_toolkitsmod = \textcolor{keyword}{nullptr}, *axis3dmod = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{491   \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{}
\DoxyCodeLine{492     detail::\_interpreter::get();}
\DoxyCodeLine{493 }
\DoxyCodeLine{494     PyObject* mpl\_toolkits = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits"{}});}
\DoxyCodeLine{495     PyObject* axis3d = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits.mplot3d"{}});}
\DoxyCodeLine{496     \textcolor{keywordflow}{if} (!mpl\_toolkits || !axis3d) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}couldnt create string"{}}); \}}
\DoxyCodeLine{497 }
\DoxyCodeLine{498     mpl\_toolkitsmod = PyImport\_Import(mpl\_toolkits);}
\DoxyCodeLine{499     Py\_DECREF(mpl\_toolkits);}
\DoxyCodeLine{500     \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits!"{}}); \}}
\DoxyCodeLine{501 }
\DoxyCodeLine{502     axis3dmod = PyImport\_Import(axis3d);}
\DoxyCodeLine{503     Py\_DECREF(axis3d);}
\DoxyCodeLine{504     \textcolor{keywordflow}{if} (!axis3dmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits.mplot3d!"{}}); \}}
\DoxyCodeLine{505   \}}
\DoxyCodeLine{506 }
\DoxyCodeLine{507   assert(x.size() == y.size());}
\DoxyCodeLine{508   assert(y.size() == z.size());}
\DoxyCodeLine{509 }
\DoxyCodeLine{510   \textcolor{comment}{// using numpy arrays}}
\DoxyCodeLine{511   PyObject *xarray = detail::get\_2darray(x);}
\DoxyCodeLine{512   PyObject *yarray = detail::get\_2darray(y);}
\DoxyCodeLine{513   PyObject *zarray = detail::get\_2darray(z);}
\DoxyCodeLine{514 }
\DoxyCodeLine{515   \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{516   PyObject *args = PyTuple\_New(3);}
\DoxyCodeLine{517   PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{518   PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{519   PyTuple\_SetItem(args, 2, zarray);}
\DoxyCodeLine{520 }
\DoxyCodeLine{521   \textcolor{comment}{// Build up the kw args.}}
\DoxyCodeLine{522   PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{523   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}rstride"{}}, PyInt\_FromLong(1));}
\DoxyCodeLine{524   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}cstride"{}}, PyInt\_FromLong(1));}
\DoxyCodeLine{525 }
\DoxyCodeLine{526   PyObject *python\_colormap\_coolwarm = PyObject\_GetAttrString(}
\DoxyCodeLine{527       detail::\_interpreter::get().s\_python\_colormap, \textcolor{stringliteral}{"{}coolwarm"{}});}
\DoxyCodeLine{528 }
\DoxyCodeLine{529   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}cmap"{}}, python\_colormap\_coolwarm);}
\DoxyCodeLine{530 }
\DoxyCodeLine{531   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin();}
\DoxyCodeLine{532        it != keywords.end(); ++it) \{}
\DoxyCodeLine{533     \textcolor{keywordflow}{if} (it-\/>first == \textcolor{stringliteral}{"{}linewidth"{}} || it-\/>first == \textcolor{stringliteral}{"{}alpha"{}}) \{}
\DoxyCodeLine{534       PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{535         PyFloat\_FromDouble(std::stod(it-\/>second)));}
\DoxyCodeLine{536     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{537       PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{538         PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{539     \}}
\DoxyCodeLine{540   \}}
\DoxyCodeLine{541 }
\DoxyCodeLine{542   PyObject *fig\_args = PyTuple\_New(1);}
\DoxyCodeLine{543   PyObject* fig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{544   PyTuple\_SetItem(fig\_args, 0, PyLong\_FromLong(fig\_number));}
\DoxyCodeLine{545   PyObject *fig\_exists =}
\DoxyCodeLine{546     PyObject\_CallObject(}
\DoxyCodeLine{547     detail::\_interpreter::get().s\_python\_function\_fignum\_exists, fig\_args);}
\DoxyCodeLine{548   \textcolor{keywordflow}{if} (!PyObject\_IsTrue(fig\_exists)) \{}
\DoxyCodeLine{549     fig = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{550       detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{551   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{552     fig = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{553       fig\_args);}
\DoxyCodeLine{554   \}}
\DoxyCodeLine{555   Py\_DECREF(fig\_exists);}
\DoxyCodeLine{556   \textcolor{keywordflow}{if} (!fig) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to figure() failed."{}});}
\DoxyCodeLine{557 }
\DoxyCodeLine{558   PyObject *gca\_kwargs = PyDict\_New();}
\DoxyCodeLine{559   PyDict\_SetItemString(gca\_kwargs, \textcolor{stringliteral}{"{}projection"{}}, PyString\_FromString(\textcolor{stringliteral}{"{}3d"{}}));}
\DoxyCodeLine{560 }
\DoxyCodeLine{561   PyObject *gca = PyObject\_GetAttrString(fig, \textcolor{stringliteral}{"{}gca"{}});}
\DoxyCodeLine{562   \textcolor{keywordflow}{if} (!gca) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No gca"{}});}
\DoxyCodeLine{563   Py\_INCREF(gca);}
\DoxyCodeLine{564   PyObject *axis = PyObject\_Call(}
\DoxyCodeLine{565       gca, detail::\_interpreter::get().s\_python\_empty\_tuple, gca\_kwargs);}
\DoxyCodeLine{566 }
\DoxyCodeLine{567   \textcolor{keywordflow}{if} (!axis) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No axis"{}});}
\DoxyCodeLine{568   Py\_INCREF(axis);}
\DoxyCodeLine{569 }
\DoxyCodeLine{570   Py\_DECREF(gca);}
\DoxyCodeLine{571   Py\_DECREF(gca\_kwargs);}
\DoxyCodeLine{572 }
\DoxyCodeLine{573   PyObject *plot\_surface = PyObject\_GetAttrString(axis, \textcolor{stringliteral}{"{}plot\_surface"{}});}
\DoxyCodeLine{574   \textcolor{keywordflow}{if} (!plot\_surface) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No surface"{}});}
\DoxyCodeLine{575   Py\_INCREF(plot\_surface);}
\DoxyCodeLine{576   PyObject *res = PyObject\_Call(plot\_surface, args, kwargs);}
\DoxyCodeLine{577   \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}failed surface"{}});}
\DoxyCodeLine{578   Py\_DECREF(plot\_surface);}
\DoxyCodeLine{579 }
\DoxyCodeLine{580   Py\_DECREF(axis);}
\DoxyCodeLine{581   Py\_DECREF(args);}
\DoxyCodeLine{582   Py\_DECREF(kwargs);}
\DoxyCodeLine{583   \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{584 \}}
\DoxyCodeLine{585 }
\DoxyCodeLine{586 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{587 \textcolor{keywordtype}{void} contour(\textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&x,}
\DoxyCodeLine{588              \textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&y,}
\DoxyCodeLine{589              \textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&z,}
\DoxyCodeLine{590              \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{591 \{}
\DoxyCodeLine{592   detail::\_interpreter::get();}
\DoxyCodeLine{593 }
\DoxyCodeLine{594   \textcolor{comment}{// using numpy arrays}}
\DoxyCodeLine{595   PyObject *xarray = detail::get\_2darray(x);}
\DoxyCodeLine{596   PyObject *yarray = detail::get\_2darray(y);}
\DoxyCodeLine{597   PyObject *zarray = detail::get\_2darray(z);}
\DoxyCodeLine{598 }
\DoxyCodeLine{599   \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{600   PyObject *args = PyTuple\_New(3);}
\DoxyCodeLine{601   PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{602   PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{603   PyTuple\_SetItem(args, 2, zarray);}
\DoxyCodeLine{604 }
\DoxyCodeLine{605   \textcolor{comment}{// Build up the kw args.}}
\DoxyCodeLine{606   PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{607 }
\DoxyCodeLine{608   PyObject *python\_colormap\_coolwarm = PyObject\_GetAttrString(}
\DoxyCodeLine{609       detail::\_interpreter::get().s\_python\_colormap, \textcolor{stringliteral}{"{}coolwarm"{}});}
\DoxyCodeLine{610 }
\DoxyCodeLine{611   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}cmap"{}}, python\_colormap\_coolwarm);}
\DoxyCodeLine{612 }
\DoxyCodeLine{613   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin();}
\DoxyCodeLine{614        it != keywords.end(); ++it) \{}
\DoxyCodeLine{615     PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{616                          PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{617   \}}
\DoxyCodeLine{618 }
\DoxyCodeLine{619   PyObject *res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_contour, args, kwargs);}
\DoxyCodeLine{620   \textcolor{keywordflow}{if} (!res)}
\DoxyCodeLine{621     \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}failed contour"{}});}
\DoxyCodeLine{622 }
\DoxyCodeLine{623   Py\_DECREF(args);}
\DoxyCodeLine{624   Py\_DECREF(kwargs);}
\DoxyCodeLine{625   \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{626 \}}
\DoxyCodeLine{627 }
\DoxyCodeLine{628 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{629 \textcolor{keywordtype}{void} spy(\textcolor{keyword}{const} std::vector<::std::vector<Numeric>> \&x,}
\DoxyCodeLine{630          \textcolor{keyword}{const} \textcolor{keywordtype}{double} markersize = -\/1,  \textcolor{comment}{// -\/1 for default matplotlib size}}
\DoxyCodeLine{631          \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{632 \{}
\DoxyCodeLine{633   detail::\_interpreter::get();}
\DoxyCodeLine{634 }
\DoxyCodeLine{635   PyObject *xarray = detail::get\_2darray(x);}
\DoxyCodeLine{636 }
\DoxyCodeLine{637   PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{638   \textcolor{keywordflow}{if} (markersize != -\/1) \{}
\DoxyCodeLine{639     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}markersize"{}}, PyFloat\_FromDouble(markersize));}
\DoxyCodeLine{640   \}}
\DoxyCodeLine{641   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin();}
\DoxyCodeLine{642        it != keywords.end(); ++it) \{}
\DoxyCodeLine{643     PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{644                          PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{645   \}}
\DoxyCodeLine{646 }
\DoxyCodeLine{647   PyObject *plot\_args = PyTuple\_New(1);}
\DoxyCodeLine{648   PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{649 }
\DoxyCodeLine{650   PyObject *res = PyObject\_Call(}
\DoxyCodeLine{651       detail::\_interpreter::get().s\_python\_function\_spy, plot\_args, kwargs);}
\DoxyCodeLine{652 }
\DoxyCodeLine{653   Py\_DECREF(plot\_args);}
\DoxyCodeLine{654   Py\_DECREF(kwargs);}
\DoxyCodeLine{655   \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{656 \}}
\DoxyCodeLine{657 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// WITHOUT\_NUMPY}}
\DoxyCodeLine{658 }
\DoxyCodeLine{659 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{660 \textcolor{keywordtype}{void} plot3(\textcolor{keyword}{const} std::vector<Numeric> \&x,}
\DoxyCodeLine{661                   \textcolor{keyword}{const} std::vector<Numeric> \&y,}
\DoxyCodeLine{662                   \textcolor{keyword}{const} std::vector<Numeric> \&z,}
\DoxyCodeLine{663                   \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords =}
\DoxyCodeLine{664                       std::map<std::string, std::string>(),}
\DoxyCodeLine{665                   \textcolor{keyword}{const} \textcolor{keywordtype}{long} fig\_number=0)}
\DoxyCodeLine{666 \{}
\DoxyCodeLine{667   detail::\_interpreter::get();}
\DoxyCodeLine{668 }
\DoxyCodeLine{669   \textcolor{comment}{// Same as with plot\_surface: We lazily load the modules here the first time}}
\DoxyCodeLine{670   \textcolor{comment}{// this function is called because I'm not sure that we can assume "{}matplotlib}}
\DoxyCodeLine{671   \textcolor{comment}{// installed"{} implies "{}mpl\_toolkits installed"{} on all platforms, and we don't}}
\DoxyCodeLine{672   \textcolor{comment}{// want to require it for people who don't need 3d plots.}}
\DoxyCodeLine{673   \textcolor{keyword}{static} PyObject *mpl\_toolkitsmod = \textcolor{keyword}{nullptr}, *axis3dmod = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{674   \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{}
\DoxyCodeLine{675     detail::\_interpreter::get();}
\DoxyCodeLine{676 }
\DoxyCodeLine{677     PyObject* mpl\_toolkits = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits"{}});}
\DoxyCodeLine{678     PyObject* axis3d = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits.mplot3d"{}});}
\DoxyCodeLine{679     \textcolor{keywordflow}{if} (!mpl\_toolkits || !axis3d) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}couldnt create string"{}}); \}}
\DoxyCodeLine{680 }
\DoxyCodeLine{681     mpl\_toolkitsmod = PyImport\_Import(mpl\_toolkits);}
\DoxyCodeLine{682     Py\_DECREF(mpl\_toolkits);}
\DoxyCodeLine{683     \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits!"{}}); \}}
\DoxyCodeLine{684 }
\DoxyCodeLine{685     axis3dmod = PyImport\_Import(axis3d);}
\DoxyCodeLine{686     Py\_DECREF(axis3d);}
\DoxyCodeLine{687     \textcolor{keywordflow}{if} (!axis3dmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits.mplot3d!"{}}); \}}
\DoxyCodeLine{688   \}}
\DoxyCodeLine{689 }
\DoxyCodeLine{690   assert(x.size() == y.size());}
\DoxyCodeLine{691   assert(y.size() == z.size());}
\DoxyCodeLine{692 }
\DoxyCodeLine{693   PyObject *xarray = detail::get\_array(x);}
\DoxyCodeLine{694   PyObject *yarray = detail::get\_array(y);}
\DoxyCodeLine{695   PyObject *zarray = detail::get\_array(z);}
\DoxyCodeLine{696 }
\DoxyCodeLine{697   \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{698   PyObject *args = PyTuple\_New(3);}
\DoxyCodeLine{699   PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{700   PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{701   PyTuple\_SetItem(args, 2, zarray);}
\DoxyCodeLine{702 }
\DoxyCodeLine{703   \textcolor{comment}{// Build up the kw args.}}
\DoxyCodeLine{704   PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{705 }
\DoxyCodeLine{706   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin();}
\DoxyCodeLine{707        it != keywords.end(); ++it) \{}
\DoxyCodeLine{708     PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{709                          PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{710   \}}
\DoxyCodeLine{711 }
\DoxyCodeLine{712   PyObject *fig\_args = PyTuple\_New(1);}
\DoxyCodeLine{713   PyObject* fig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{714   PyTuple\_SetItem(fig\_args, 0, PyLong\_FromLong(fig\_number));}
\DoxyCodeLine{715   PyObject *fig\_exists =}
\DoxyCodeLine{716     PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_fignum\_exists, fig\_args);}
\DoxyCodeLine{717   \textcolor{keywordflow}{if} (!PyObject\_IsTrue(fig\_exists)) \{}
\DoxyCodeLine{718     fig = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{719       detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{720   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{721     fig = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{722       fig\_args);}
\DoxyCodeLine{723   \}}
\DoxyCodeLine{724   \textcolor{keywordflow}{if} (!fig) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to figure() failed."{}});}
\DoxyCodeLine{725 }
\DoxyCodeLine{726   PyObject *gca\_kwargs = PyDict\_New();}
\DoxyCodeLine{727   PyDict\_SetItemString(gca\_kwargs, \textcolor{stringliteral}{"{}projection"{}}, PyString\_FromString(\textcolor{stringliteral}{"{}3d"{}}));}
\DoxyCodeLine{728 }
\DoxyCodeLine{729   PyObject *gca = PyObject\_GetAttrString(fig, \textcolor{stringliteral}{"{}gca"{}});}
\DoxyCodeLine{730   \textcolor{keywordflow}{if} (!gca) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No gca"{}});}
\DoxyCodeLine{731   Py\_INCREF(gca);}
\DoxyCodeLine{732   PyObject *axis = PyObject\_Call(}
\DoxyCodeLine{733       gca, detail::\_interpreter::get().s\_python\_empty\_tuple, gca\_kwargs);}
\DoxyCodeLine{734 }
\DoxyCodeLine{735   \textcolor{keywordflow}{if} (!axis) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No axis"{}});}
\DoxyCodeLine{736   Py\_INCREF(axis);}
\DoxyCodeLine{737 }
\DoxyCodeLine{738   Py\_DECREF(gca);}
\DoxyCodeLine{739   Py\_DECREF(gca\_kwargs);}
\DoxyCodeLine{740 }
\DoxyCodeLine{741   PyObject *plot3 = PyObject\_GetAttrString(axis, \textcolor{stringliteral}{"{}plot"{}});}
\DoxyCodeLine{742   \textcolor{keywordflow}{if} (!plot3) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No 3D line plot"{}});}
\DoxyCodeLine{743   Py\_INCREF(plot3);}
\DoxyCodeLine{744   PyObject *res = PyObject\_Call(plot3, args, kwargs);}
\DoxyCodeLine{745   \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Failed 3D line plot"{}});}
\DoxyCodeLine{746   Py\_DECREF(plot3);}
\DoxyCodeLine{747 }
\DoxyCodeLine{748   Py\_DECREF(axis);}
\DoxyCodeLine{749   Py\_DECREF(args);}
\DoxyCodeLine{750   Py\_DECREF(kwargs);}
\DoxyCodeLine{751   \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{752 \}}
\DoxyCodeLine{753 }
\DoxyCodeLine{754 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{755 \textcolor{keywordtype}{bool} stem(\textcolor{keyword}{const} std::vector<Numeric> \&x, \textcolor{keyword}{const} std::vector<Numeric> \&y, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{756 \{}
\DoxyCodeLine{757     assert(x.size() == y.size());}
\DoxyCodeLine{758 }
\DoxyCodeLine{759     detail::\_interpreter::get();}
\DoxyCodeLine{760 }
\DoxyCodeLine{761     \textcolor{comment}{// using numpy arrays}}
\DoxyCodeLine{762     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{763     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{764 }
\DoxyCodeLine{765     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{766     PyObject* args = PyTuple\_New(2);}
\DoxyCodeLine{767     PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{768     PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{769 }
\DoxyCodeLine{770     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{771     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{772     \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it =}
\DoxyCodeLine{773             keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{774         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{775                 PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{776     \}}
\DoxyCodeLine{777 }
\DoxyCodeLine{778     PyObject* res = PyObject\_Call(}
\DoxyCodeLine{779             detail::\_interpreter::get().s\_python\_function\_stem, args, kwargs);}
\DoxyCodeLine{780 }
\DoxyCodeLine{781     Py\_DECREF(args);}
\DoxyCodeLine{782     Py\_DECREF(kwargs);}
\DoxyCodeLine{783     \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{784         Py\_DECREF(res);}
\DoxyCodeLine{785 }
\DoxyCodeLine{786     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{787 \}}
\DoxyCodeLine{788 }
\DoxyCodeLine{789 \textcolor{keyword}{template}< \textcolor{keyword}{typename} Numeric >}
\DoxyCodeLine{790 \textcolor{keywordtype}{bool} fill(\textcolor{keyword}{const} std::vector<Numeric>\& x, \textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{791 \{}
\DoxyCodeLine{792     assert(x.size() == y.size());}
\DoxyCodeLine{793 }
\DoxyCodeLine{794     detail::\_interpreter::get();}
\DoxyCodeLine{795 }
\DoxyCodeLine{796     \textcolor{comment}{// using numpy arrays}}
\DoxyCodeLine{797     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{798     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{799 }
\DoxyCodeLine{800     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{801     PyObject* args = PyTuple\_New(2);}
\DoxyCodeLine{802     PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{803     PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{804 }
\DoxyCodeLine{805     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{806     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{807     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{808         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{809     \}}
\DoxyCodeLine{810 }
\DoxyCodeLine{811     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_fill, args, kwargs);}
\DoxyCodeLine{812 }
\DoxyCodeLine{813     Py\_DECREF(args);}
\DoxyCodeLine{814     Py\_DECREF(kwargs);}
\DoxyCodeLine{815 }
\DoxyCodeLine{816     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{817 }
\DoxyCodeLine{818     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{819 \}}
\DoxyCodeLine{820 }
\DoxyCodeLine{821 \textcolor{keyword}{template}< \textcolor{keyword}{typename} Numeric >}
\DoxyCodeLine{822 \textcolor{keywordtype}{bool} fill\_between(\textcolor{keyword}{const} std::vector<Numeric>\& x, \textcolor{keyword}{const} std::vector<Numeric>\& y1, \textcolor{keyword}{const} std::vector<Numeric>\& y2, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{823 \{}
\DoxyCodeLine{824     assert(x.size() == y1.size());}
\DoxyCodeLine{825     assert(x.size() == y2.size());}
\DoxyCodeLine{826 }
\DoxyCodeLine{827     detail::\_interpreter::get();}
\DoxyCodeLine{828 }
\DoxyCodeLine{829     \textcolor{comment}{// using numpy arrays}}
\DoxyCodeLine{830     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{831     PyObject* y1array = detail::get\_array(y1);}
\DoxyCodeLine{832     PyObject* y2array = detail::get\_array(y2);}
\DoxyCodeLine{833 }
\DoxyCodeLine{834     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{835     PyObject* args = PyTuple\_New(3);}
\DoxyCodeLine{836     PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{837     PyTuple\_SetItem(args, 1, y1array);}
\DoxyCodeLine{838     PyTuple\_SetItem(args, 2, y2array);}
\DoxyCodeLine{839 }
\DoxyCodeLine{840     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{841     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{842     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{843         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{844     \}}
\DoxyCodeLine{845 }
\DoxyCodeLine{846     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_fill\_between, args, kwargs);}
\DoxyCodeLine{847 }
\DoxyCodeLine{848     Py\_DECREF(args);}
\DoxyCodeLine{849     Py\_DECREF(kwargs);}
\DoxyCodeLine{850     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{851 }
\DoxyCodeLine{852     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{853 \}}
\DoxyCodeLine{854 }
\DoxyCodeLine{855 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{856 \textcolor{keywordtype}{bool} arrow(Numeric x, Numeric y, Numeric end\_x, Numeric end\_y, \textcolor{keyword}{const} std::string\& fc = \textcolor{stringliteral}{"{}r"{}},}
\DoxyCodeLine{857            \textcolor{keyword}{const} std::string ec = \textcolor{stringliteral}{"{}k"{}}, Numeric head\_length = 0.25, Numeric head\_width = 0.1625) \{}
\DoxyCodeLine{858     PyObject* obj\_x = PyFloat\_FromDouble(x);}
\DoxyCodeLine{859     PyObject* obj\_y = PyFloat\_FromDouble(y);}
\DoxyCodeLine{860     PyObject* obj\_end\_x = PyFloat\_FromDouble(end\_x);}
\DoxyCodeLine{861     PyObject* obj\_end\_y = PyFloat\_FromDouble(end\_y);}
\DoxyCodeLine{862 }
\DoxyCodeLine{863     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{864     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}fc"{}}, PyString\_FromString(fc.c\_str()));}
\DoxyCodeLine{865     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}ec"{}}, PyString\_FromString(ec.c\_str()));}
\DoxyCodeLine{866     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}head\_width"{}}, PyFloat\_FromDouble(head\_width));}
\DoxyCodeLine{867     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}head\_length"{}}, PyFloat\_FromDouble(head\_length));}
\DoxyCodeLine{868 }
\DoxyCodeLine{869     PyObject* plot\_args = PyTuple\_New(4);}
\DoxyCodeLine{870     PyTuple\_SetItem(plot\_args, 0, obj\_x);}
\DoxyCodeLine{871     PyTuple\_SetItem(plot\_args, 1, obj\_y);}
\DoxyCodeLine{872     PyTuple\_SetItem(plot\_args, 2, obj\_end\_x);}
\DoxyCodeLine{873     PyTuple\_SetItem(plot\_args, 3, obj\_end\_y);}
\DoxyCodeLine{874 }
\DoxyCodeLine{875     PyObject* res =}
\DoxyCodeLine{876             PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_arrow, plot\_args, kwargs);}
\DoxyCodeLine{877 }
\DoxyCodeLine{878     Py\_DECREF(plot\_args);}
\DoxyCodeLine{879     Py\_DECREF(kwargs);}
\DoxyCodeLine{880     \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{881         Py\_DECREF(res);}
\DoxyCodeLine{882 }
\DoxyCodeLine{883     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{884 \}}
\DoxyCodeLine{885 }
\DoxyCodeLine{886 \textcolor{keyword}{template}< \textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{887 \textcolor{keywordtype}{bool} hist(\textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keywordtype}{long} bins=10,std::string color=\textcolor{stringliteral}{"{}b"{}},}
\DoxyCodeLine{888           \textcolor{keywordtype}{double} alpha=1.0, \textcolor{keywordtype}{bool} cumulative=\textcolor{keyword}{false})}
\DoxyCodeLine{889 \{}
\DoxyCodeLine{890     detail::\_interpreter::get();}
\DoxyCodeLine{891 }
\DoxyCodeLine{892     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{893 }
\DoxyCodeLine{894     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{895     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}bins"{}}, PyLong\_FromLong(bins));}
\DoxyCodeLine{896     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}color"{}}, PyString\_FromString(color.c\_str()));}
\DoxyCodeLine{897     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}alpha"{}}, PyFloat\_FromDouble(alpha));}
\DoxyCodeLine{898     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}cumulative"{}}, cumulative ? Py\_True : Py\_False);}
\DoxyCodeLine{899 }
\DoxyCodeLine{900     PyObject* plot\_args = PyTuple\_New(1);}
\DoxyCodeLine{901 }
\DoxyCodeLine{902     PyTuple\_SetItem(plot\_args, 0, yarray);}
\DoxyCodeLine{903 }
\DoxyCodeLine{904 }
\DoxyCodeLine{905     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_hist, plot\_args, kwargs);}
\DoxyCodeLine{906 }
\DoxyCodeLine{907 }
\DoxyCodeLine{908     Py\_DECREF(plot\_args);}
\DoxyCodeLine{909     Py\_DECREF(kwargs);}
\DoxyCodeLine{910     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{911 }
\DoxyCodeLine{912     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{913 \}}
\DoxyCodeLine{914 }
\DoxyCodeLine{915 \textcolor{preprocessor}{\#ifndef WITHOUT\_NUMPY}}
\DoxyCodeLine{916 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{917 }
\DoxyCodeLine{918 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} imshow(\textcolor{keywordtype}{void} *ptr, \textcolor{keyword}{const} NPY\_TYPES type, \textcolor{keyword}{const} \textcolor{keywordtype}{int} rows, \textcolor{keyword}{const} \textcolor{keywordtype}{int} columns, \textcolor{keyword}{const} \textcolor{keywordtype}{int} colors, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords, PyObject** out)}
\DoxyCodeLine{919 \{}
\DoxyCodeLine{920     assert(type == NPY\_UINT8 || type == NPY\_FLOAT);}
\DoxyCodeLine{921     assert(colors == 1 || colors == 3 || colors == 4);}
\DoxyCodeLine{922 }
\DoxyCodeLine{923     detail::\_interpreter::get();}
\DoxyCodeLine{924 }
\DoxyCodeLine{925     \textcolor{comment}{// construct args}}
\DoxyCodeLine{926     npy\_intp dims[3] = \{ rows, columns, colors \};}
\DoxyCodeLine{927     PyObject *args = PyTuple\_New(1);}
\DoxyCodeLine{928     PyTuple\_SetItem(args, 0, PyArray\_SimpleNewFromData(colors == 1 ? 2 : 3, dims, type, ptr));}
\DoxyCodeLine{929 }
\DoxyCodeLine{930     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{931     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{932     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{933     \{}
\DoxyCodeLine{934         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{935     \}}
\DoxyCodeLine{936 }
\DoxyCodeLine{937     PyObject *res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_imshow, args, kwargs);}
\DoxyCodeLine{938     Py\_DECREF(args);}
\DoxyCodeLine{939     Py\_DECREF(kwargs);}
\DoxyCodeLine{940     \textcolor{keywordflow}{if} (!res)}
\DoxyCodeLine{941         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to imshow() failed"{}});}
\DoxyCodeLine{942     \textcolor{keywordflow}{if} (out)}
\DoxyCodeLine{943         *out = res;}
\DoxyCodeLine{944     \textcolor{keywordflow}{else}}
\DoxyCodeLine{945         Py\_DECREF(res);}
\DoxyCodeLine{946 \}}
\DoxyCodeLine{947 }
\DoxyCodeLine{948 \} \textcolor{comment}{// namespace detail}}
\DoxyCodeLine{949 }
\DoxyCodeLine{950 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} imshow(\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *ptr, \textcolor{keyword}{const} \textcolor{keywordtype}{int} rows, \textcolor{keyword}{const} \textcolor{keywordtype}{int} columns, \textcolor{keyword}{const} \textcolor{keywordtype}{int} colors, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\}, PyObject** out = \textcolor{keyword}{nullptr})}
\DoxyCodeLine{951 \{}
\DoxyCodeLine{952     detail::imshow((\textcolor{keywordtype}{void} *) ptr, NPY\_UINT8, rows, columns, colors, keywords, out);}
\DoxyCodeLine{953 \}}
\DoxyCodeLine{954 }
\DoxyCodeLine{955 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} imshow(\textcolor{keyword}{const} \textcolor{keywordtype}{float} *ptr, \textcolor{keyword}{const} \textcolor{keywordtype}{int} rows, \textcolor{keyword}{const} \textcolor{keywordtype}{int} columns, \textcolor{keyword}{const} \textcolor{keywordtype}{int} colors, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\}, PyObject** out = \textcolor{keyword}{nullptr})}
\DoxyCodeLine{956 \{}
\DoxyCodeLine{957     detail::imshow((\textcolor{keywordtype}{void} *) ptr, NPY\_FLOAT, rows, columns, colors, keywords, out);}
\DoxyCodeLine{958 \}}
\DoxyCodeLine{959 }
\DoxyCodeLine{960 \textcolor{preprocessor}{\#ifdef WITH\_OPENCV}}
\DoxyCodeLine{961 \textcolor{keywordtype}{void} imshow(\textcolor{keyword}{const} cv::Mat \&image, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{962 \{}
\DoxyCodeLine{963     \textcolor{comment}{// Convert underlying type of matrix, if needed}}
\DoxyCodeLine{964     cv::Mat image2;}
\DoxyCodeLine{965     NPY\_TYPES npy\_type = NPY\_UINT8;}
\DoxyCodeLine{966     \textcolor{keywordflow}{switch} (image.type() \& CV\_MAT\_DEPTH\_MASK) \{}
\DoxyCodeLine{967     \textcolor{keywordflow}{case} CV\_8U:}
\DoxyCodeLine{968         image2 = image;}
\DoxyCodeLine{969         \textcolor{keywordflow}{break};}
\DoxyCodeLine{970     \textcolor{keywordflow}{case} CV\_32F:}
\DoxyCodeLine{971         image2 = image;}
\DoxyCodeLine{972         npy\_type = NPY\_FLOAT;}
\DoxyCodeLine{973         \textcolor{keywordflow}{break};}
\DoxyCodeLine{974     \textcolor{keywordflow}{default}:}
\DoxyCodeLine{975         image.convertTo(image2, CV\_MAKETYPE(CV\_8U, image.channels()));}
\DoxyCodeLine{976     \}}
\DoxyCodeLine{977 }
\DoxyCodeLine{978     \textcolor{comment}{// If color image, convert from BGR to RGB}}
\DoxyCodeLine{979     \textcolor{keywordflow}{switch} (image2.channels()) \{}
\DoxyCodeLine{980     \textcolor{keywordflow}{case} 3:}
\DoxyCodeLine{981         cv::cvtColor(image2, image2, CV\_BGR2RGB);}
\DoxyCodeLine{982         \textcolor{keywordflow}{break};}
\DoxyCodeLine{983     \textcolor{keywordflow}{case} 4:}
\DoxyCodeLine{984         cv::cvtColor(image2, image2, CV\_BGRA2RGBA);}
\DoxyCodeLine{985     \}}
\DoxyCodeLine{986 }
\DoxyCodeLine{987     detail::imshow(image2.data, npy\_type, image2.rows, image2.cols, image2.channels(), keywords);}
\DoxyCodeLine{988 \}}
\DoxyCodeLine{989 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// WITH\_OPENCV}}
\DoxyCodeLine{990 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// WITHOUT\_NUMPY}}
\DoxyCodeLine{991 }
\DoxyCodeLine{992 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{993 \textcolor{keywordtype}{bool} scatter(\textcolor{keyword}{const} std::vector<NumericX>\& x,}
\DoxyCodeLine{994              \textcolor{keyword}{const} std::vector<NumericY>\& y,}
\DoxyCodeLine{995              \textcolor{keyword}{const} \textcolor{keywordtype}{double} s=1.0, \textcolor{comment}{// The marker size in points**2}}
\DoxyCodeLine{996              \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\})}
\DoxyCodeLine{997 \{}
\DoxyCodeLine{998     detail::\_interpreter::get();}
\DoxyCodeLine{999 }
\DoxyCodeLine{1000     assert(x.size() == y.size());}
\DoxyCodeLine{1001 }
\DoxyCodeLine{1002     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1003     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1004 }
\DoxyCodeLine{1005     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1006     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}s"{}}, PyLong\_FromLong(s));}
\DoxyCodeLine{1007     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& it : keywords)}
\DoxyCodeLine{1008     \{}
\DoxyCodeLine{1009         PyDict\_SetItemString(kwargs, it.first.c\_str(), PyString\_FromString(it.second.c\_str()));}
\DoxyCodeLine{1010     \}}
\DoxyCodeLine{1011 }
\DoxyCodeLine{1012     PyObject* plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{1013     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1014     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1015 }
\DoxyCodeLine{1016     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_scatter, plot\_args, kwargs);}
\DoxyCodeLine{1017 }
\DoxyCodeLine{1018     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1019     Py\_DECREF(kwargs);}
\DoxyCodeLine{1020     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1021 }
\DoxyCodeLine{1022     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1023 \}}
\DoxyCodeLine{1024 }
\DoxyCodeLine{1025 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY, \textcolor{keyword}{typename} NumericColors>}
\DoxyCodeLine{1026     \textcolor{keywordtype}{bool} scatter\_colored(\textcolor{keyword}{const} std::vector<NumericX>\& x,}
\DoxyCodeLine{1027                  \textcolor{keyword}{const} std::vector<NumericY>\& y,}
\DoxyCodeLine{1028                  \textcolor{keyword}{const} std::vector<NumericColors>\& colors,}
\DoxyCodeLine{1029                  \textcolor{keyword}{const} \textcolor{keywordtype}{double} s=1.0, \textcolor{comment}{// The marker size in points**2}}
\DoxyCodeLine{1030                  \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\})}
\DoxyCodeLine{1031     \{}
\DoxyCodeLine{1032         detail::\_interpreter::get();}
\DoxyCodeLine{1033 }
\DoxyCodeLine{1034         assert(x.size() == y.size());}
\DoxyCodeLine{1035 }
\DoxyCodeLine{1036         PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1037         PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1038         PyObject* colors\_array = detail::get\_array(colors);}
\DoxyCodeLine{1039 }
\DoxyCodeLine{1040         PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1041         PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}s"{}}, PyLong\_FromLong(s));}
\DoxyCodeLine{1042         PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}c"{}}, colors\_array);}
\DoxyCodeLine{1043 }
\DoxyCodeLine{1044         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& it : keywords)}
\DoxyCodeLine{1045         \{}
\DoxyCodeLine{1046             PyDict\_SetItemString(kwargs, it.first.c\_str(), PyString\_FromString(it.second.c\_str()));}
\DoxyCodeLine{1047         \}}
\DoxyCodeLine{1048 }
\DoxyCodeLine{1049         PyObject* plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{1050         PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1051         PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1052 }
\DoxyCodeLine{1053         PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_scatter, plot\_args, kwargs);}
\DoxyCodeLine{1054 }
\DoxyCodeLine{1055         Py\_DECREF(plot\_args);}
\DoxyCodeLine{1056         Py\_DECREF(kwargs);}
\DoxyCodeLine{1057         \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1059         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1060     \}}
\DoxyCodeLine{1061     }
\DoxyCodeLine{1062 }
\DoxyCodeLine{1063 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY, \textcolor{keyword}{typename} NumericZ>}
\DoxyCodeLine{1064 \textcolor{keywordtype}{bool} scatter(\textcolor{keyword}{const} std::vector<NumericX>\& x,}
\DoxyCodeLine{1065              \textcolor{keyword}{const} std::vector<NumericY>\& y,}
\DoxyCodeLine{1066              \textcolor{keyword}{const} std::vector<NumericZ>\& z,}
\DoxyCodeLine{1067              \textcolor{keyword}{const} \textcolor{keywordtype}{double} s=1.0, \textcolor{comment}{// The marker size in points**2}}
\DoxyCodeLine{1068              \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\},}
\DoxyCodeLine{1069              \textcolor{keyword}{const} \textcolor{keywordtype}{long} fig\_number=0) \{}
\DoxyCodeLine{1070   detail::\_interpreter::get();}
\DoxyCodeLine{1071 }
\DoxyCodeLine{1072   \textcolor{comment}{// Same as with plot\_surface: We lazily load the modules here the first time }}
\DoxyCodeLine{1073   \textcolor{comment}{// this function is called because I'm not sure that we can assume "{}matplotlib }}
\DoxyCodeLine{1074   \textcolor{comment}{// installed"{} implies "{}mpl\_toolkits installed"{} on all platforms, and we don't }}
\DoxyCodeLine{1075   \textcolor{comment}{// want to require it for people who don't need 3d plots.}}
\DoxyCodeLine{1076   \textcolor{keyword}{static} PyObject *mpl\_toolkitsmod = \textcolor{keyword}{nullptr}, *axis3dmod = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1077   \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{}
\DoxyCodeLine{1078     detail::\_interpreter::get();}
\DoxyCodeLine{1079 }
\DoxyCodeLine{1080     PyObject* mpl\_toolkits = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits"{}});}
\DoxyCodeLine{1081     PyObject* axis3d = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits.mplot3d"{}});}
\DoxyCodeLine{1082     \textcolor{keywordflow}{if} (!mpl\_toolkits || !axis3d) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}couldnt create string"{}}); \}}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084     mpl\_toolkitsmod = PyImport\_Import(mpl\_toolkits);}
\DoxyCodeLine{1085     Py\_DECREF(mpl\_toolkits);}
\DoxyCodeLine{1086     \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits!"{}}); \}}
\DoxyCodeLine{1087 }
\DoxyCodeLine{1088     axis3dmod = PyImport\_Import(axis3d);}
\DoxyCodeLine{1089     Py\_DECREF(axis3d);}
\DoxyCodeLine{1090     \textcolor{keywordflow}{if} (!axis3dmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits.mplot3d!"{}}); \}}
\DoxyCodeLine{1091   \}}
\DoxyCodeLine{1092 }
\DoxyCodeLine{1093   assert(x.size() == y.size());}
\DoxyCodeLine{1094   assert(y.size() == z.size());}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1096   PyObject *xarray = detail::get\_array(x);}
\DoxyCodeLine{1097   PyObject *yarray = detail::get\_array(y);}
\DoxyCodeLine{1098   PyObject *zarray = detail::get\_array(z);}
\DoxyCodeLine{1099 }
\DoxyCodeLine{1100   \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{1101   PyObject *args = PyTuple\_New(3);}
\DoxyCodeLine{1102   PyTuple\_SetItem(args, 0, xarray);}
\DoxyCodeLine{1103   PyTuple\_SetItem(args, 1, yarray);}
\DoxyCodeLine{1104   PyTuple\_SetItem(args, 2, zarray);}
\DoxyCodeLine{1105 }
\DoxyCodeLine{1106   \textcolor{comment}{// Build up the kw args.}}
\DoxyCodeLine{1107   PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin();}
\DoxyCodeLine{1110        it != keywords.end(); ++it) \{}
\DoxyCodeLine{1111     PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{1112                          PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1113   \}}
\DoxyCodeLine{1114   PyObject *fig\_args = PyTuple\_New(1);}
\DoxyCodeLine{1115   PyObject* fig = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1116   PyTuple\_SetItem(fig\_args, 0, PyLong\_FromLong(fig\_number));}
\DoxyCodeLine{1117   PyObject *fig\_exists =}
\DoxyCodeLine{1118     PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_fignum\_exists, fig\_args);}
\DoxyCodeLine{1119   \textcolor{keywordflow}{if} (!PyObject\_IsTrue(fig\_exists)) \{}
\DoxyCodeLine{1120     fig = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{1121       detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{1122   \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1123     fig = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{1124       fig\_args);}
\DoxyCodeLine{1125   \}}
\DoxyCodeLine{1126   Py\_DECREF(fig\_exists);}
\DoxyCodeLine{1127   \textcolor{keywordflow}{if} (!fig) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to figure() failed."{}});}
\DoxyCodeLine{1128 }
\DoxyCodeLine{1129   PyObject *gca\_kwargs = PyDict\_New();}
\DoxyCodeLine{1130   PyDict\_SetItemString(gca\_kwargs, \textcolor{stringliteral}{"{}projection"{}}, PyString\_FromString(\textcolor{stringliteral}{"{}3d"{}}));}
\DoxyCodeLine{1131 }
\DoxyCodeLine{1132   PyObject *gca = PyObject\_GetAttrString(fig, \textcolor{stringliteral}{"{}gca"{}});}
\DoxyCodeLine{1133   \textcolor{keywordflow}{if} (!gca) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No gca"{}});}
\DoxyCodeLine{1134   Py\_INCREF(gca);}
\DoxyCodeLine{1135   PyObject *axis = PyObject\_Call(}
\DoxyCodeLine{1136       gca, detail::\_interpreter::get().s\_python\_empty\_tuple, gca\_kwargs);}
\DoxyCodeLine{1137 }
\DoxyCodeLine{1138   \textcolor{keywordflow}{if} (!axis) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No axis"{}});}
\DoxyCodeLine{1139   Py\_INCREF(axis);}
\DoxyCodeLine{1140 }
\DoxyCodeLine{1141   Py\_DECREF(gca);}
\DoxyCodeLine{1142   Py\_DECREF(gca\_kwargs);}
\DoxyCodeLine{1143 }
\DoxyCodeLine{1144   PyObject *plot3 = PyObject\_GetAttrString(axis, \textcolor{stringliteral}{"{}scatter"{}});}
\DoxyCodeLine{1145   \textcolor{keywordflow}{if} (!plot3) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No 3D line plot"{}});}
\DoxyCodeLine{1146   Py\_INCREF(plot3);}
\DoxyCodeLine{1147   PyObject *res = PyObject\_Call(plot3, args, kwargs);}
\DoxyCodeLine{1148   \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Failed 3D line plot"{}});}
\DoxyCodeLine{1149   Py\_DECREF(plot3);}
\DoxyCodeLine{1150 }
\DoxyCodeLine{1151   Py\_DECREF(axis);}
\DoxyCodeLine{1152   Py\_DECREF(args);}
\DoxyCodeLine{1153   Py\_DECREF(kwargs);}
\DoxyCodeLine{1154   Py\_DECREF(fig);}
\DoxyCodeLine{1155   \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1156   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1157 }
\DoxyCodeLine{1158 \}}
\DoxyCodeLine{1159 }
\DoxyCodeLine{1160 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1161 \textcolor{keywordtype}{bool} boxplot(\textcolor{keyword}{const} std::vector<std::vector<Numeric>>\& data,}
\DoxyCodeLine{1162              \textcolor{keyword}{const} std::vector<std::string>\& labels = \{\},}
\DoxyCodeLine{1163              \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\})}
\DoxyCodeLine{1164 \{}
\DoxyCodeLine{1165     detail::\_interpreter::get();}
\DoxyCodeLine{1166 }
\DoxyCodeLine{1167     PyObject* listlist = detail::get\_listlist(data);}
\DoxyCodeLine{1168     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{1169     PyTuple\_SetItem(args, 0, listlist);}
\DoxyCodeLine{1170 }
\DoxyCodeLine{1171     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1172 }
\DoxyCodeLine{1173     \textcolor{comment}{// kwargs needs the labels, if there are (the correct number of) labels}}
\DoxyCodeLine{1174     \textcolor{keywordflow}{if} (!labels.empty() \&\& labels.size() == data.size()) \{}
\DoxyCodeLine{1175         PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}labels"{}}, detail::get\_array(labels));}
\DoxyCodeLine{1176     \}}
\DoxyCodeLine{1177 }
\DoxyCodeLine{1178     \textcolor{comment}{// take care of the remaining keywords}}
\DoxyCodeLine{1179     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& it : keywords)}
\DoxyCodeLine{1180     \{}
\DoxyCodeLine{1181         PyDict\_SetItemString(kwargs, it.first.c\_str(), PyString\_FromString(it.second.c\_str()));}
\DoxyCodeLine{1182     \}}
\DoxyCodeLine{1183 }
\DoxyCodeLine{1184     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_boxplot, args, kwargs);}
\DoxyCodeLine{1185 }
\DoxyCodeLine{1186     Py\_DECREF(args);}
\DoxyCodeLine{1187     Py\_DECREF(kwargs);}
\DoxyCodeLine{1188 }
\DoxyCodeLine{1189     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1190 }
\DoxyCodeLine{1191     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1192 \}}
\DoxyCodeLine{1193 }
\DoxyCodeLine{1194 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1195 \textcolor{keywordtype}{bool} boxplot(\textcolor{keyword}{const} std::vector<Numeric>\& data,}
\DoxyCodeLine{1196              \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\})}
\DoxyCodeLine{1197 \{}
\DoxyCodeLine{1198     detail::\_interpreter::get();}
\DoxyCodeLine{1199 }
\DoxyCodeLine{1200     PyObject* vector = detail::get\_array(data);}
\DoxyCodeLine{1201     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{1202     PyTuple\_SetItem(args, 0, vector);}
\DoxyCodeLine{1203 }
\DoxyCodeLine{1204     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1205     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& it : keywords)}
\DoxyCodeLine{1206     \{}
\DoxyCodeLine{1207         PyDict\_SetItemString(kwargs, it.first.c\_str(), PyString\_FromString(it.second.c\_str()));}
\DoxyCodeLine{1208     \}}
\DoxyCodeLine{1209 }
\DoxyCodeLine{1210     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_boxplot, args, kwargs);}
\DoxyCodeLine{1211 }
\DoxyCodeLine{1212     Py\_DECREF(args);}
\DoxyCodeLine{1213     Py\_DECREF(kwargs);}
\DoxyCodeLine{1214 }
\DoxyCodeLine{1215     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1216 }
\DoxyCodeLine{1217     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1218 \}}
\DoxyCodeLine{1219 }
\DoxyCodeLine{1220 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1221 \textcolor{keywordtype}{bool} bar(\textcolor{keyword}{const} std::vector<Numeric> \&               x,}
\DoxyCodeLine{1222          \textcolor{keyword}{const} std::vector<Numeric> \&               y,}
\DoxyCodeLine{1223          std::string                                ec       = \textcolor{stringliteral}{"{}black"{}},}
\DoxyCodeLine{1224          std::string                                ls       = \textcolor{stringliteral}{"{}-\/"{}},}
\DoxyCodeLine{1225          \textcolor{keywordtype}{double}                                     lw       = 1.0,}
\DoxyCodeLine{1226          \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\})}
\DoxyCodeLine{1227 \{}
\DoxyCodeLine{1228   detail::\_interpreter::get();}
\DoxyCodeLine{1229 }
\DoxyCodeLine{1230   PyObject * xarray = detail::get\_array(x);}
\DoxyCodeLine{1231   PyObject * yarray = detail::get\_array(y);}
\DoxyCodeLine{1232 }
\DoxyCodeLine{1233   PyObject * kwargs = PyDict\_New();}
\DoxyCodeLine{1234 }
\DoxyCodeLine{1235   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}ec"{}}, PyString\_FromString(ec.c\_str()));}
\DoxyCodeLine{1236   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}ls"{}}, PyString\_FromString(ls.c\_str()));}
\DoxyCodeLine{1237   PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}lw"{}}, PyFloat\_FromDouble(lw));}
\DoxyCodeLine{1238 }
\DoxyCodeLine{1239   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it =}
\DoxyCodeLine{1240          keywords.begin();}
\DoxyCodeLine{1241        it != keywords.end();}
\DoxyCodeLine{1242        ++it) \{}
\DoxyCodeLine{1243     PyDict\_SetItemString(}
\DoxyCodeLine{1244       kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1245   \}}
\DoxyCodeLine{1246 }
\DoxyCodeLine{1247   PyObject * plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{1248   PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1249   PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1250 }
\DoxyCodeLine{1251   PyObject * res = PyObject\_Call(}
\DoxyCodeLine{1252     detail::\_interpreter::get().s\_python\_function\_bar, plot\_args, kwargs);}
\DoxyCodeLine{1253 }
\DoxyCodeLine{1254   Py\_DECREF(plot\_args);}
\DoxyCodeLine{1255   Py\_DECREF(kwargs);}
\DoxyCodeLine{1256   \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1257 }
\DoxyCodeLine{1258   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1259 \}}
\DoxyCodeLine{1260 }
\DoxyCodeLine{1261 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1262 \textcolor{keywordtype}{bool} bar(\textcolor{keyword}{const} std::vector<Numeric> \&               y,}
\DoxyCodeLine{1263          std::string                                ec       = \textcolor{stringliteral}{"{}black"{}},}
\DoxyCodeLine{1264          std::string                                ls       = \textcolor{stringliteral}{"{}-\/"{}},}
\DoxyCodeLine{1265          \textcolor{keywordtype}{double}                                     lw       = 1.0,}
\DoxyCodeLine{1266          \textcolor{keyword}{const} std::map<std::string, std::string> \& keywords = \{\})}
\DoxyCodeLine{1267 \{}
\DoxyCodeLine{1268   \textcolor{keyword}{using }T = \textcolor{keyword}{typename} std::remove\_reference<\textcolor{keyword}{decltype}(y)>::type::value\_type;}
\DoxyCodeLine{1269 }
\DoxyCodeLine{1270   detail::\_interpreter::get();}
\DoxyCodeLine{1271 }
\DoxyCodeLine{1272   std::vector<T> x;}
\DoxyCodeLine{1273   \textcolor{keywordflow}{for} (std::size\_t i = 0; i < y.size(); i++) \{ x.push\_back(i); \}}
\DoxyCodeLine{1274 }
\DoxyCodeLine{1275   \textcolor{keywordflow}{return} bar(x, y, ec, ls, lw, keywords);}
\DoxyCodeLine{1276 \}}
\DoxyCodeLine{1277 }
\DoxyCodeLine{1278 }
\DoxyCodeLine{1279 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1280 \textcolor{keywordtype}{bool} barh(\textcolor{keyword}{const} std::vector<Numeric> \&x, \textcolor{keyword}{const} std::vector<Numeric> \&y, std::string ec = \textcolor{stringliteral}{"{}black"{}}, std::string ls = \textcolor{stringliteral}{"{}-\/"{}}, \textcolor{keywordtype}{double} lw = 1.0, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{ \}) \{}
\DoxyCodeLine{1281     PyObject *xarray = detail::get\_array(x);}
\DoxyCodeLine{1282     PyObject *yarray = detail::get\_array(y);}
\DoxyCodeLine{1283 }
\DoxyCodeLine{1284     PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{1285 }
\DoxyCodeLine{1286     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}ec"{}}, PyString\_FromString(ec.c\_str()));}
\DoxyCodeLine{1287     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}ls"{}}, PyString\_FromString(ls.c\_str()));}
\DoxyCodeLine{1288     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}lw"{}}, PyFloat\_FromDouble(lw));}
\DoxyCodeLine{1289 }
\DoxyCodeLine{1290     \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{1291         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1292     \}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294     PyObject *plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{1295     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1296     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1297 }
\DoxyCodeLine{1298     PyObject *res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_barh, plot\_args, kwargs);}
\DoxyCodeLine{1299 }
\DoxyCodeLine{1300     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1301     Py\_DECREF(kwargs);}
\DoxyCodeLine{1302     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1303 }
\DoxyCodeLine{1304     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1305 \}}
\DoxyCodeLine{1306 }
\DoxyCodeLine{1307 }
\DoxyCodeLine{1308 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} subplots\_adjust(\textcolor{keyword}{const} std::map<std::string, double>\& keywords = \{\})}
\DoxyCodeLine{1309 \{}
\DoxyCodeLine{1310     detail::\_interpreter::get();}
\DoxyCodeLine{1311 }
\DoxyCodeLine{1312     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1313     \textcolor{keywordflow}{for} (std::map<std::string, double>::const\_iterator it =}
\DoxyCodeLine{1314             keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{1315         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{1316                              PyFloat\_FromDouble(it-\/>second));}
\DoxyCodeLine{1317     \}}
\DoxyCodeLine{1318 }
\DoxyCodeLine{1319 }
\DoxyCodeLine{1320     PyObject* plot\_args = PyTuple\_New(0);}
\DoxyCodeLine{1321 }
\DoxyCodeLine{1322     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_subplots\_adjust, plot\_args, kwargs);}
\DoxyCodeLine{1323 }
\DoxyCodeLine{1324     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1325     Py\_DECREF(kwargs);}
\DoxyCodeLine{1326     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1327 }
\DoxyCodeLine{1328     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1329 \}}
\DoxyCodeLine{1330 }
\DoxyCodeLine{1331 \textcolor{keyword}{template}< \textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1332 \textcolor{keywordtype}{bool} named\_hist(std::string label,\textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keywordtype}{long} bins=10, std::string color=\textcolor{stringliteral}{"{}b"{}}, \textcolor{keywordtype}{double} alpha=1.0)}
\DoxyCodeLine{1333 \{}
\DoxyCodeLine{1334     detail::\_interpreter::get();}
\DoxyCodeLine{1335 }
\DoxyCodeLine{1336     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1337 }
\DoxyCodeLine{1338     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1339     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(label.c\_str()));}
\DoxyCodeLine{1340     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}bins"{}}, PyLong\_FromLong(bins));}
\DoxyCodeLine{1341     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}color"{}}, PyString\_FromString(color.c\_str()));}
\DoxyCodeLine{1342     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}alpha"{}}, PyFloat\_FromDouble(alpha));}
\DoxyCodeLine{1343 }
\DoxyCodeLine{1344 }
\DoxyCodeLine{1345     PyObject* plot\_args = PyTuple\_New(1);}
\DoxyCodeLine{1346     PyTuple\_SetItem(plot\_args, 0, yarray);}
\DoxyCodeLine{1347 }
\DoxyCodeLine{1348     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_hist, plot\_args, kwargs);}
\DoxyCodeLine{1349 }
\DoxyCodeLine{1350     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1351     Py\_DECREF(kwargs);}
\DoxyCodeLine{1352     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1353 }
\DoxyCodeLine{1354     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1355 \}}
\DoxyCodeLine{1356 }
\DoxyCodeLine{1357 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1358 \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1359 \{}
\DoxyCodeLine{1360     assert(x.size() == y.size());}
\DoxyCodeLine{1361 }
\DoxyCodeLine{1362     detail::\_interpreter::get();}
\DoxyCodeLine{1363 }
\DoxyCodeLine{1364     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1365     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1366 }
\DoxyCodeLine{1367     PyObject* pystring = PyString\_FromString(s.c\_str());}
\DoxyCodeLine{1368 }
\DoxyCodeLine{1369     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1370     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1371     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1372     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1373 }
\DoxyCodeLine{1374     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_plot, plot\_args);}
\DoxyCodeLine{1375 }
\DoxyCodeLine{1376     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1377     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1378 }
\DoxyCodeLine{1379     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1380 \}}
\DoxyCodeLine{1381 }
\DoxyCodeLine{1382 \textcolor{keyword}{template} <\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY, \textcolor{keyword}{typename} NumericZ>}
\DoxyCodeLine{1383 \textcolor{keywordtype}{bool} contour(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y,}
\DoxyCodeLine{1384              \textcolor{keyword}{const} std::vector<NumericZ>\& z,}
\DoxyCodeLine{1385              \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\}) \{}
\DoxyCodeLine{1386     assert(x.size() == y.size() \&\& x.size() == z.size());}
\DoxyCodeLine{1387 }
\DoxyCodeLine{1388     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1389     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1390     PyObject* zarray = detail::get\_array(z);}
\DoxyCodeLine{1391 }
\DoxyCodeLine{1392     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1393     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1394     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1395     PyTuple\_SetItem(plot\_args, 2, zarray);}
\DoxyCodeLine{1396 }
\DoxyCodeLine{1397     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{1398     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1399     \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin();}
\DoxyCodeLine{1400          it != keywords.end(); ++it) \{}
\DoxyCodeLine{1401         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1402     \}}
\DoxyCodeLine{1403 }
\DoxyCodeLine{1404     PyObject* res =}
\DoxyCodeLine{1405             PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_contour, plot\_args, kwargs);}
\DoxyCodeLine{1406 }
\DoxyCodeLine{1407     Py\_DECREF(kwargs);}
\DoxyCodeLine{1408     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1409     \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{1410         Py\_DECREF(res);}
\DoxyCodeLine{1411 }
\DoxyCodeLine{1412     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1413 \}}
\DoxyCodeLine{1414 }
\DoxyCodeLine{1415 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY, \textcolor{keyword}{typename} NumericU, \textcolor{keyword}{typename} NumericW>}
\DoxyCodeLine{1416 \textcolor{keywordtype}{bool} quiver(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::vector<NumericU>\& u, \textcolor{keyword}{const} std::vector<NumericW>\& w, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{1417 \{}
\DoxyCodeLine{1418     assert(x.size() == y.size() \&\& x.size() == u.size() \&\& u.size() == w.size());}
\DoxyCodeLine{1419 }
\DoxyCodeLine{1420     detail::\_interpreter::get();}
\DoxyCodeLine{1421 }
\DoxyCodeLine{1422     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1423     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1424     PyObject* uarray = detail::get\_array(u);}
\DoxyCodeLine{1425     PyObject* warray = detail::get\_array(w);}
\DoxyCodeLine{1426 }
\DoxyCodeLine{1427     PyObject* plot\_args = PyTuple\_New(4);}
\DoxyCodeLine{1428     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1429     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1430     PyTuple\_SetItem(plot\_args, 2, uarray);}
\DoxyCodeLine{1431     PyTuple\_SetItem(plot\_args, 3, warray);}
\DoxyCodeLine{1432 }
\DoxyCodeLine{1433     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{1434     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1435     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{1436     \{}
\DoxyCodeLine{1437         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1438     \}}
\DoxyCodeLine{1439 }
\DoxyCodeLine{1440     PyObject* res = PyObject\_Call(}
\DoxyCodeLine{1441             detail::\_interpreter::get().s\_python\_function\_quiver, plot\_args, kwargs);}
\DoxyCodeLine{1442 }
\DoxyCodeLine{1443     Py\_DECREF(kwargs);}
\DoxyCodeLine{1444     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1445     \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{1446         Py\_DECREF(res);}
\DoxyCodeLine{1447 }
\DoxyCodeLine{1448     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1449 \}}
\DoxyCodeLine{1450 }
\DoxyCodeLine{1451 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY, \textcolor{keyword}{typename} NumericZ, \textcolor{keyword}{typename} NumericU, \textcolor{keyword}{typename} NumericW, \textcolor{keyword}{typename} NumericV>}
\DoxyCodeLine{1452 \textcolor{keywordtype}{bool} quiver(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::vector<NumericZ>\& z, \textcolor{keyword}{const} std::vector<NumericU>\& u, \textcolor{keyword}{const} std::vector<NumericW>\& w, \textcolor{keyword}{const} std::vector<NumericV>\& v, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{1453 \{}
\DoxyCodeLine{1454   \textcolor{comment}{//set up 3d axes stuff}}
\DoxyCodeLine{1455   \textcolor{keyword}{static} PyObject *mpl\_toolkitsmod = \textcolor{keyword}{nullptr}, *axis3dmod = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{1456   \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{}
\DoxyCodeLine{1457     detail::\_interpreter::get();}
\DoxyCodeLine{1458 }
\DoxyCodeLine{1459     PyObject* mpl\_toolkits = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits"{}});}
\DoxyCodeLine{1460     PyObject* axis3d = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits.mplot3d"{}});}
\DoxyCodeLine{1461     \textcolor{keywordflow}{if} (!mpl\_toolkits || !axis3d) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}couldnt create string"{}}); \}}
\DoxyCodeLine{1462 }
\DoxyCodeLine{1463     mpl\_toolkitsmod = PyImport\_Import(mpl\_toolkits);}
\DoxyCodeLine{1464     Py\_DECREF(mpl\_toolkits);}
\DoxyCodeLine{1465     \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits!"{}}); \}}
\DoxyCodeLine{1466 }
\DoxyCodeLine{1467     axis3dmod = PyImport\_Import(axis3d);}
\DoxyCodeLine{1468     Py\_DECREF(axis3d);}
\DoxyCodeLine{1469     \textcolor{keywordflow}{if} (!axis3dmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits.mplot3d!"{}}); \}}
\DoxyCodeLine{1470   \}}
\DoxyCodeLine{1471   }
\DoxyCodeLine{1472   \textcolor{comment}{//assert sizes match up}}
\DoxyCodeLine{1473   assert(x.size() == y.size() \&\& x.size() == u.size() \&\& u.size() == w.size() \&\& x.size() == z.size() \&\& x.size() == v.size() \&\& u.size() == v.size());}
\DoxyCodeLine{1474 }
\DoxyCodeLine{1475   \textcolor{comment}{//set up parameters}}
\DoxyCodeLine{1476   detail::\_interpreter::get();}
\DoxyCodeLine{1477 }
\DoxyCodeLine{1478   PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1479   PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1480   PyObject* zarray = detail::get\_array(z);}
\DoxyCodeLine{1481   PyObject* uarray = detail::get\_array(u);}
\DoxyCodeLine{1482   PyObject* warray = detail::get\_array(w);}
\DoxyCodeLine{1483   PyObject* varray = detail::get\_array(v);}
\DoxyCodeLine{1484 }
\DoxyCodeLine{1485   PyObject* plot\_args = PyTuple\_New(6);}
\DoxyCodeLine{1486   PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1487   PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1488   PyTuple\_SetItem(plot\_args, 2, zarray);}
\DoxyCodeLine{1489   PyTuple\_SetItem(plot\_args, 3, uarray);}
\DoxyCodeLine{1490   PyTuple\_SetItem(plot\_args, 4, warray);}
\DoxyCodeLine{1491   PyTuple\_SetItem(plot\_args, 5, varray);}
\DoxyCodeLine{1492 }
\DoxyCodeLine{1493   \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{1494   PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1495   \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{1496   \{}
\DoxyCodeLine{1497       PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1498   \}}
\DoxyCodeLine{1499     }
\DoxyCodeLine{1500   \textcolor{comment}{//get figure gca to enable 3d projection}}
\DoxyCodeLine{1501   PyObject *fig =}
\DoxyCodeLine{1502       PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{1503                           detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{1504   \textcolor{keywordflow}{if} (!fig) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to figure() failed."{}});}
\DoxyCodeLine{1505 }
\DoxyCodeLine{1506   PyObject *gca\_kwargs = PyDict\_New();}
\DoxyCodeLine{1507   PyDict\_SetItemString(gca\_kwargs, \textcolor{stringliteral}{"{}projection"{}}, PyString\_FromString(\textcolor{stringliteral}{"{}3d"{}}));}
\DoxyCodeLine{1508 }
\DoxyCodeLine{1509   PyObject *gca = PyObject\_GetAttrString(fig, \textcolor{stringliteral}{"{}gca"{}});}
\DoxyCodeLine{1510   \textcolor{keywordflow}{if} (!gca) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No gca"{}});}
\DoxyCodeLine{1511   Py\_INCREF(gca);}
\DoxyCodeLine{1512   PyObject *axis = PyObject\_Call(}
\DoxyCodeLine{1513       gca, detail::\_interpreter::get().s\_python\_empty\_tuple, gca\_kwargs);}
\DoxyCodeLine{1514 }
\DoxyCodeLine{1515   \textcolor{keywordflow}{if} (!axis) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No axis"{}});}
\DoxyCodeLine{1516   Py\_INCREF(axis);}
\DoxyCodeLine{1517   Py\_DECREF(gca);}
\DoxyCodeLine{1518   Py\_DECREF(gca\_kwargs);}
\DoxyCodeLine{1519   }
\DoxyCodeLine{1520   \textcolor{comment}{//plot our boys bravely, plot them strongly, plot them with a wink and clap}}
\DoxyCodeLine{1521   PyObject *plot3 = PyObject\_GetAttrString(axis, \textcolor{stringliteral}{"{}quiver"{}});}
\DoxyCodeLine{1522   \textcolor{keywordflow}{if} (!plot3) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}No 3D line plot"{}});}
\DoxyCodeLine{1523   Py\_INCREF(plot3);}
\DoxyCodeLine{1524   PyObject* res = PyObject\_Call(}
\DoxyCodeLine{1525           plot3, plot\_args, kwargs);}
\DoxyCodeLine{1526   \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Failed 3D plot"{}});}
\DoxyCodeLine{1527   Py\_DECREF(plot3);}
\DoxyCodeLine{1528   Py\_DECREF(axis);}
\DoxyCodeLine{1529   Py\_DECREF(kwargs);}
\DoxyCodeLine{1530   Py\_DECREF(plot\_args);}
\DoxyCodeLine{1531   \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{1532       Py\_DECREF(res);}
\DoxyCodeLine{1533 }
\DoxyCodeLine{1534   \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1535 \}}
\DoxyCodeLine{1536 }
\DoxyCodeLine{1537 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1538 \textcolor{keywordtype}{bool} stem(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1539 \{}
\DoxyCodeLine{1540     assert(x.size() == y.size());}
\DoxyCodeLine{1541 }
\DoxyCodeLine{1542     detail::\_interpreter::get();}
\DoxyCodeLine{1543 }
\DoxyCodeLine{1544     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1545     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1546 }
\DoxyCodeLine{1547     PyObject* pystring = PyString\_FromString(s.c\_str());}
\DoxyCodeLine{1548 }
\DoxyCodeLine{1549     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1550     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1551     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1552     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1553 }
\DoxyCodeLine{1554     PyObject* res = PyObject\_CallObject(}
\DoxyCodeLine{1555             detail::\_interpreter::get().s\_python\_function\_stem, plot\_args);}
\DoxyCodeLine{1556 }
\DoxyCodeLine{1557     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1558     \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{1559         Py\_DECREF(res);}
\DoxyCodeLine{1560 }
\DoxyCodeLine{1561     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1562 \}}
\DoxyCodeLine{1563 }
\DoxyCodeLine{1564 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1565 \textcolor{keywordtype}{bool} semilogx(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1566 \{}
\DoxyCodeLine{1567     assert(x.size() == y.size());}
\DoxyCodeLine{1568 }
\DoxyCodeLine{1569     detail::\_interpreter::get();}
\DoxyCodeLine{1570 }
\DoxyCodeLine{1571     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1572     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1573 }
\DoxyCodeLine{1574     PyObject* pystring = PyString\_FromString(s.c\_str());}
\DoxyCodeLine{1575 }
\DoxyCodeLine{1576     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1577     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1578     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1579     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1580 }
\DoxyCodeLine{1581     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_semilogx, plot\_args);}
\DoxyCodeLine{1582 }
\DoxyCodeLine{1583     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1584     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1585 }
\DoxyCodeLine{1586     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1587 \}}
\DoxyCodeLine{1588 }
\DoxyCodeLine{1589 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1590 \textcolor{keywordtype}{bool} semilogy(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1591 \{}
\DoxyCodeLine{1592     assert(x.size() == y.size());}
\DoxyCodeLine{1593 }
\DoxyCodeLine{1594     detail::\_interpreter::get();}
\DoxyCodeLine{1595 }
\DoxyCodeLine{1596     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1597     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1598 }
\DoxyCodeLine{1599     PyObject* pystring = PyString\_FromString(s.c\_str());}
\DoxyCodeLine{1600 }
\DoxyCodeLine{1601     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1602     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1603     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1604     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1605 }
\DoxyCodeLine{1606     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_semilogy, plot\_args);}
\DoxyCodeLine{1607 }
\DoxyCodeLine{1608     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1609     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1610 }
\DoxyCodeLine{1611     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1612 \}}
\DoxyCodeLine{1613 }
\DoxyCodeLine{1614 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1615 \textcolor{keywordtype}{bool} loglog(\textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1616 \{}
\DoxyCodeLine{1617     assert(x.size() == y.size());}
\DoxyCodeLine{1618 }
\DoxyCodeLine{1619     detail::\_interpreter::get();}
\DoxyCodeLine{1620 }
\DoxyCodeLine{1621     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1622     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1623 }
\DoxyCodeLine{1624     PyObject* pystring = PyString\_FromString(s.c\_str());}
\DoxyCodeLine{1625 }
\DoxyCodeLine{1626     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1627     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1628     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1629     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1630 }
\DoxyCodeLine{1631     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_loglog, plot\_args);}
\DoxyCodeLine{1632 }
\DoxyCodeLine{1633     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1634     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{1635 }
\DoxyCodeLine{1636     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1637 \}}
\DoxyCodeLine{1638 }
\DoxyCodeLine{1639 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1640 \textcolor{keywordtype}{bool} errorbar(\textcolor{keyword}{const} std::vector<NumericX> \&x, \textcolor{keyword}{const} std::vector<NumericY> \&y, \textcolor{keyword}{const} std::vector<NumericX> \&yerr, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{1641 \{}
\DoxyCodeLine{1642     assert(x.size() == y.size());}
\DoxyCodeLine{1643 }
\DoxyCodeLine{1644     detail::\_interpreter::get();}
\DoxyCodeLine{1645 }
\DoxyCodeLine{1646     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1647     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1648     PyObject* yerrarray = detail::get\_array(yerr);}
\DoxyCodeLine{1649 }
\DoxyCodeLine{1650     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{1651     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1652     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{1653     \{}
\DoxyCodeLine{1654         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1655     \}}
\DoxyCodeLine{1656 }
\DoxyCodeLine{1657     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}yerr"{}}, yerrarray);}
\DoxyCodeLine{1658 }
\DoxyCodeLine{1659     PyObject *plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{1660     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1661     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1662 }
\DoxyCodeLine{1663     PyObject *res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_errorbar, plot\_args, kwargs);}
\DoxyCodeLine{1664 }
\DoxyCodeLine{1665     Py\_DECREF(kwargs);}
\DoxyCodeLine{1666     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1667 }
\DoxyCodeLine{1668     \textcolor{keywordflow}{if} (res)}
\DoxyCodeLine{1669         Py\_DECREF(res);}
\DoxyCodeLine{1670     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1671         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to errorbar() failed."{}});}
\DoxyCodeLine{1672 }
\DoxyCodeLine{1673     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1674 \}}
\DoxyCodeLine{1675 }
\DoxyCodeLine{1676 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1677 \textcolor{keywordtype}{bool} named\_plot(\textcolor{keyword}{const} std::string\& name, \textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1678 \{}
\DoxyCodeLine{1679     detail::\_interpreter::get();}
\DoxyCodeLine{1680 }
\DoxyCodeLine{1681     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1682     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(name.c\_str()));}
\DoxyCodeLine{1683 }
\DoxyCodeLine{1684     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1685 }
\DoxyCodeLine{1686     PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{1687 }
\DoxyCodeLine{1688     PyObject* plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{1689 }
\DoxyCodeLine{1690     PyTuple\_SetItem(plot\_args, 0, yarray);}
\DoxyCodeLine{1691     PyTuple\_SetItem(plot\_args, 1, pystring);}
\DoxyCodeLine{1692 }
\DoxyCodeLine{1693     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_plot, plot\_args, kwargs);}
\DoxyCodeLine{1694 }
\DoxyCodeLine{1695     Py\_DECREF(kwargs);}
\DoxyCodeLine{1696     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1697     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1698 }
\DoxyCodeLine{1699     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1700 \}}
\DoxyCodeLine{1701 }
\DoxyCodeLine{1702 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1703 \textcolor{keywordtype}{bool} named\_plot(\textcolor{keyword}{const} std::string\& name, \textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1704 \{}
\DoxyCodeLine{1705     detail::\_interpreter::get();}
\DoxyCodeLine{1706 }
\DoxyCodeLine{1707     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1708     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(name.c\_str()));}
\DoxyCodeLine{1709 }
\DoxyCodeLine{1710     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1711     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1712 }
\DoxyCodeLine{1713     PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{1714 }
\DoxyCodeLine{1715     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1716     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1717     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1718     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1719 }
\DoxyCodeLine{1720     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_plot, plot\_args, kwargs);}
\DoxyCodeLine{1721 }
\DoxyCodeLine{1722     Py\_DECREF(kwargs);}
\DoxyCodeLine{1723     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1724     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1725 }
\DoxyCodeLine{1726     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1727 \}}
\DoxyCodeLine{1728 }
\DoxyCodeLine{1729 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1730 \textcolor{keywordtype}{bool} named\_semilogx(\textcolor{keyword}{const} std::string\& name, \textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1731 \{}
\DoxyCodeLine{1732     detail::\_interpreter::get();}
\DoxyCodeLine{1733 }
\DoxyCodeLine{1734     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1735     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(name.c\_str()));}
\DoxyCodeLine{1736 }
\DoxyCodeLine{1737     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1738     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1739 }
\DoxyCodeLine{1740     PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{1741 }
\DoxyCodeLine{1742     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1743     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1744     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1745     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1746 }
\DoxyCodeLine{1747     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_semilogx, plot\_args, kwargs);}
\DoxyCodeLine{1748 }
\DoxyCodeLine{1749     Py\_DECREF(kwargs);}
\DoxyCodeLine{1750     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1751     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1752 }
\DoxyCodeLine{1753     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1754 \}}
\DoxyCodeLine{1755 }
\DoxyCodeLine{1756 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1757 \textcolor{keywordtype}{bool} named\_semilogy(\textcolor{keyword}{const} std::string\& name, \textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1758 \{}
\DoxyCodeLine{1759     detail::\_interpreter::get();}
\DoxyCodeLine{1760 }
\DoxyCodeLine{1761     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1762     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(name.c\_str()));}
\DoxyCodeLine{1763 }
\DoxyCodeLine{1764     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1765     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1766 }
\DoxyCodeLine{1767     PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{1768 }
\DoxyCodeLine{1769     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1770     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1771     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1772     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1773 }
\DoxyCodeLine{1774     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_semilogy, plot\_args, kwargs);}
\DoxyCodeLine{1775 }
\DoxyCodeLine{1776     Py\_DECREF(kwargs);}
\DoxyCodeLine{1777     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1778     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1779 }
\DoxyCodeLine{1780     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1781 \}}
\DoxyCodeLine{1782 }
\DoxyCodeLine{1783 \textcolor{keyword}{template}<\textcolor{keyword}{typename} NumericX, \textcolor{keyword}{typename} NumericY>}
\DoxyCodeLine{1784 \textcolor{keywordtype}{bool} named\_loglog(\textcolor{keyword}{const} std::string\& name, \textcolor{keyword}{const} std::vector<NumericX>\& x, \textcolor{keyword}{const} std::vector<NumericY>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1785 \{}
\DoxyCodeLine{1786     detail::\_interpreter::get();}
\DoxyCodeLine{1787 }
\DoxyCodeLine{1788     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1789     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(name.c\_str()));}
\DoxyCodeLine{1790 }
\DoxyCodeLine{1791     PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{1792     PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{1793 }
\DoxyCodeLine{1794     PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{1795 }
\DoxyCodeLine{1796     PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{1797     PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{1798     PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{1799     PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{1800     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_loglog, plot\_args, kwargs);}
\DoxyCodeLine{1801 }
\DoxyCodeLine{1802     Py\_DECREF(kwargs);}
\DoxyCodeLine{1803     Py\_DECREF(plot\_args);}
\DoxyCodeLine{1804     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{1805 }
\DoxyCodeLine{1806     \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{1807 \}}
\DoxyCodeLine{1808 }
\DoxyCodeLine{1809 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1810 \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1811 \{}
\DoxyCodeLine{1812     std::vector<Numeric> x(y.size());}
\DoxyCodeLine{1813     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<x.size(); ++i) x.at(i) = i;}
\DoxyCodeLine{1814     \textcolor{keywordflow}{return} plot(x,y,format);}
\DoxyCodeLine{1815 \}}
\DoxyCodeLine{1816 }
\DoxyCodeLine{1817 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1818 \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{1819 \{}
\DoxyCodeLine{1820     std::vector<Numeric> x(y.size());}
\DoxyCodeLine{1821     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i=0; i<x.size(); ++i) x.at(i) = i;}
\DoxyCodeLine{1822     \textcolor{keywordflow}{return} plot(x,y,keywords);}
\DoxyCodeLine{1823 \}}
\DoxyCodeLine{1824 }
\DoxyCodeLine{1825 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1826 \textcolor{keywordtype}{bool} stem(\textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1827 \{}
\DoxyCodeLine{1828     std::vector<Numeric> x(y.size());}
\DoxyCodeLine{1829     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < x.size(); ++i) x.at(i) = i;}
\DoxyCodeLine{1830     \textcolor{keywordflow}{return} stem(x, y, format);}
\DoxyCodeLine{1831 \}}
\DoxyCodeLine{1832 }
\DoxyCodeLine{1833 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1834 \textcolor{keywordtype}{void} text(Numeric x, Numeric y, \textcolor{keyword}{const} std::string\& s = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{1835 \{}
\DoxyCodeLine{1836     detail::\_interpreter::get();}
\DoxyCodeLine{1837 }
\DoxyCodeLine{1838     PyObject* args = PyTuple\_New(3);}
\DoxyCodeLine{1839     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(x));}
\DoxyCodeLine{1840     PyTuple\_SetItem(args, 1, PyFloat\_FromDouble(y));}
\DoxyCodeLine{1841     PyTuple\_SetItem(args, 2, PyString\_FromString(s.c\_str()));}
\DoxyCodeLine{1842 }
\DoxyCodeLine{1843     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_text, args);}
\DoxyCodeLine{1844     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to text() failed."{}});}
\DoxyCodeLine{1845 }
\DoxyCodeLine{1846     Py\_DECREF(args);}
\DoxyCodeLine{1847     Py\_DECREF(res);}
\DoxyCodeLine{1848 \}}
\DoxyCodeLine{1849 }
\DoxyCodeLine{1850 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} colorbar(PyObject* mappable = NULL, \textcolor{keyword}{const} std::map<std::string, float>\& keywords = \{\})}
\DoxyCodeLine{1851 \{}
\DoxyCodeLine{1852     \textcolor{keywordflow}{if} (mappable == NULL)}
\DoxyCodeLine{1853         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Must call colorbar with PyObject* returned from an image, contour, surface, etc."{}});}
\DoxyCodeLine{1854 }
\DoxyCodeLine{1855     detail::\_interpreter::get();}
\DoxyCodeLine{1856 }
\DoxyCodeLine{1857     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{1858     PyTuple\_SetItem(args, 0, mappable);}
\DoxyCodeLine{1859 }
\DoxyCodeLine{1860     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1861     \textcolor{keywordflow}{for}(std::map<std::string, float>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{1862     \{}
\DoxyCodeLine{1863         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyFloat\_FromDouble(it-\/>second));}
\DoxyCodeLine{1864     \}}
\DoxyCodeLine{1865 }
\DoxyCodeLine{1866     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_colorbar, args, kwargs);}
\DoxyCodeLine{1867     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to colorbar() failed."{}});}
\DoxyCodeLine{1868 }
\DoxyCodeLine{1869     Py\_DECREF(args);}
\DoxyCodeLine{1870     Py\_DECREF(kwargs);}
\DoxyCodeLine{1871     Py\_DECREF(res);}
\DoxyCodeLine{1872 \}}
\DoxyCodeLine{1873 }
\DoxyCodeLine{1874 }
\DoxyCodeLine{1875 \textcolor{keyword}{inline} \textcolor{keywordtype}{long} figure(\textcolor{keywordtype}{long} number = -\/1)}
\DoxyCodeLine{1876 \{}
\DoxyCodeLine{1877     detail::\_interpreter::get();}
\DoxyCodeLine{1878 }
\DoxyCodeLine{1879     PyObject *res;}
\DoxyCodeLine{1880     \textcolor{keywordflow}{if} (number == -\/1)}
\DoxyCodeLine{1881         res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure, detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{1882     \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{1883         assert(number > 0);}
\DoxyCodeLine{1884 }
\DoxyCodeLine{1885         \textcolor{comment}{// Make sure interpreter is initialised}}
\DoxyCodeLine{1886         detail::\_interpreter::get();}
\DoxyCodeLine{1887 }
\DoxyCodeLine{1888         PyObject *args = PyTuple\_New(1);}
\DoxyCodeLine{1889         PyTuple\_SetItem(args, 0, PyLong\_FromLong(number));}
\DoxyCodeLine{1890         res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_figure, args);}
\DoxyCodeLine{1891         Py\_DECREF(args);}
\DoxyCodeLine{1892     \}}
\DoxyCodeLine{1893 }
\DoxyCodeLine{1894     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to figure() failed."{}});}
\DoxyCodeLine{1895 }
\DoxyCodeLine{1896     PyObject* num = PyObject\_GetAttrString(res, \textcolor{stringliteral}{"{}number"{}});}
\DoxyCodeLine{1897     \textcolor{keywordflow}{if} (!num) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Could not get number attribute of figure object"{}});}
\DoxyCodeLine{1898     \textcolor{keyword}{const} \textcolor{keywordtype}{long} figureNumber = PyLong\_AsLong(num);}
\DoxyCodeLine{1899 }
\DoxyCodeLine{1900     Py\_DECREF(num);}
\DoxyCodeLine{1901     Py\_DECREF(res);}
\DoxyCodeLine{1902 }
\DoxyCodeLine{1903     \textcolor{keywordflow}{return} figureNumber;}
\DoxyCodeLine{1904 \}}
\DoxyCodeLine{1905 }
\DoxyCodeLine{1906 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} fignum\_exists(\textcolor{keywordtype}{long} number)}
\DoxyCodeLine{1907 \{}
\DoxyCodeLine{1908     detail::\_interpreter::get();}
\DoxyCodeLine{1909 }
\DoxyCodeLine{1910     PyObject *args = PyTuple\_New(1);}
\DoxyCodeLine{1911     PyTuple\_SetItem(args, 0, PyLong\_FromLong(number));}
\DoxyCodeLine{1912     PyObject *res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_fignum\_exists, args);}
\DoxyCodeLine{1913     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to fignum\_exists() failed."{}});}
\DoxyCodeLine{1914 }
\DoxyCodeLine{1915     \textcolor{keywordtype}{bool} ret = PyObject\_IsTrue(res);}
\DoxyCodeLine{1916     Py\_DECREF(res);}
\DoxyCodeLine{1917     Py\_DECREF(args);}
\DoxyCodeLine{1918 }
\DoxyCodeLine{1919     \textcolor{keywordflow}{return} ret;}
\DoxyCodeLine{1920 \}}
\DoxyCodeLine{1921 }
\DoxyCodeLine{1922 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} figure\_size(\textcolor{keywordtype}{size\_t} w, \textcolor{keywordtype}{size\_t} h)}
\DoxyCodeLine{1923 \{}
\DoxyCodeLine{1924     detail::\_interpreter::get();}
\DoxyCodeLine{1925 }
\DoxyCodeLine{1926     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} dpi = 100;}
\DoxyCodeLine{1927     PyObject* size = PyTuple\_New(2);}
\DoxyCodeLine{1928     PyTuple\_SetItem(size, 0, PyFloat\_FromDouble((\textcolor{keywordtype}{double})w / dpi));}
\DoxyCodeLine{1929     PyTuple\_SetItem(size, 1, PyFloat\_FromDouble((\textcolor{keywordtype}{double})h / dpi));}
\DoxyCodeLine{1930 }
\DoxyCodeLine{1931     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1932     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}figsize"{}}, size);}
\DoxyCodeLine{1933     PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}dpi"{}}, PyLong\_FromSize\_t(dpi));}
\DoxyCodeLine{1934 }
\DoxyCodeLine{1935     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_figure,}
\DoxyCodeLine{1936             detail::\_interpreter::get().s\_python\_empty\_tuple, kwargs);}
\DoxyCodeLine{1937 }
\DoxyCodeLine{1938     Py\_DECREF(kwargs);}
\DoxyCodeLine{1939 }
\DoxyCodeLine{1940     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to figure\_size() failed."{}});}
\DoxyCodeLine{1941     Py\_DECREF(res);}
\DoxyCodeLine{1942 \}}
\DoxyCodeLine{1943 }
\DoxyCodeLine{1944 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} legend()}
\DoxyCodeLine{1945 \{}
\DoxyCodeLine{1946     detail::\_interpreter::get();}
\DoxyCodeLine{1947 }
\DoxyCodeLine{1948     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_legend, detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{1949     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to legend() failed."{}});}
\DoxyCodeLine{1950 }
\DoxyCodeLine{1951     Py\_DECREF(res);}
\DoxyCodeLine{1952 \}}
\DoxyCodeLine{1953 }
\DoxyCodeLine{1954 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} legend(\textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{1955 \{}
\DoxyCodeLine{1956   detail::\_interpreter::get();}
\DoxyCodeLine{1957 }
\DoxyCodeLine{1958   \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{1959   PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1960   \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{1961   \{}
\DoxyCodeLine{1962     PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{1963   \}}
\DoxyCodeLine{1964 }
\DoxyCodeLine{1965   PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_legend, detail::\_interpreter::get().s\_python\_empty\_tuple, kwargs);}
\DoxyCodeLine{1966   \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to legend() failed."{}});}
\DoxyCodeLine{1967 }
\DoxyCodeLine{1968   Py\_DECREF(kwargs);}
\DoxyCodeLine{1969   Py\_DECREF(res);}
\DoxyCodeLine{1970 \}}
\DoxyCodeLine{1971 }
\DoxyCodeLine{1972 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{1973 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} set\_aspect(Numeric ratio)}
\DoxyCodeLine{1974 \{}
\DoxyCodeLine{1975     detail::\_interpreter::get();}
\DoxyCodeLine{1976 }
\DoxyCodeLine{1977     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{1978     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(ratio));}
\DoxyCodeLine{1979     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{1980 }
\DoxyCodeLine{1981     PyObject *ax =}
\DoxyCodeLine{1982     PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_gca,}
\DoxyCodeLine{1983       detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{1984     \textcolor{keywordflow}{if} (!ax) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to gca() failed."{}});}
\DoxyCodeLine{1985     Py\_INCREF(ax);}
\DoxyCodeLine{1986 }
\DoxyCodeLine{1987     PyObject *set\_aspect = PyObject\_GetAttrString(ax, \textcolor{stringliteral}{"{}set\_aspect"{}});}
\DoxyCodeLine{1988     \textcolor{keywordflow}{if} (!set\_aspect) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Attribute set\_aspect not found."{}});}
\DoxyCodeLine{1989     Py\_INCREF(set\_aspect);}
\DoxyCodeLine{1990 }
\DoxyCodeLine{1991     PyObject *res = PyObject\_Call(set\_aspect, args, kwargs);}
\DoxyCodeLine{1992     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to set\_aspect() failed."{}});}
\DoxyCodeLine{1993     Py\_DECREF(set\_aspect);}
\DoxyCodeLine{1994 }
\DoxyCodeLine{1995     Py\_DECREF(ax);}
\DoxyCodeLine{1996     Py\_DECREF(args);}
\DoxyCodeLine{1997     Py\_DECREF(kwargs);}
\DoxyCodeLine{1998 \}}
\DoxyCodeLine{1999 }
\DoxyCodeLine{2000 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} set\_aspect\_equal()}
\DoxyCodeLine{2001 \{}
\DoxyCodeLine{2002     \textcolor{comment}{// expect ratio == "{}equal"{}. Leaving error handling to matplotlib.}}
\DoxyCodeLine{2003     detail::\_interpreter::get();}
\DoxyCodeLine{2004 }
\DoxyCodeLine{2005     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2006     PyTuple\_SetItem(args, 0, PyString\_FromString(\textcolor{stringliteral}{"{}equal"{}}));}
\DoxyCodeLine{2007     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2008 }
\DoxyCodeLine{2009     PyObject *ax =}
\DoxyCodeLine{2010     PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_gca,}
\DoxyCodeLine{2011       detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2012     \textcolor{keywordflow}{if} (!ax) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to gca() failed."{}});}
\DoxyCodeLine{2013     Py\_INCREF(ax);}
\DoxyCodeLine{2014 }
\DoxyCodeLine{2015     PyObject *set\_aspect = PyObject\_GetAttrString(ax, \textcolor{stringliteral}{"{}set\_aspect"{}});}
\DoxyCodeLine{2016     \textcolor{keywordflow}{if} (!set\_aspect) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Attribute set\_aspect not found."{}});}
\DoxyCodeLine{2017     Py\_INCREF(set\_aspect);}
\DoxyCodeLine{2018 }
\DoxyCodeLine{2019     PyObject *res = PyObject\_Call(set\_aspect, args, kwargs);}
\DoxyCodeLine{2020     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to set\_aspect() failed."{}});}
\DoxyCodeLine{2021     Py\_DECREF(set\_aspect);}
\DoxyCodeLine{2022 }
\DoxyCodeLine{2023     Py\_DECREF(ax);}
\DoxyCodeLine{2024     Py\_DECREF(args);}
\DoxyCodeLine{2025     Py\_DECREF(kwargs);}
\DoxyCodeLine{2026 \}}
\DoxyCodeLine{2027 }
\DoxyCodeLine{2028 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2029 \textcolor{keywordtype}{void} ylim(Numeric left, Numeric right)}
\DoxyCodeLine{2030 \{}
\DoxyCodeLine{2031     detail::\_interpreter::get();}
\DoxyCodeLine{2032 }
\DoxyCodeLine{2033     PyObject* list = PyList\_New(2);}
\DoxyCodeLine{2034     PyList\_SetItem(list, 0, PyFloat\_FromDouble(left));}
\DoxyCodeLine{2035     PyList\_SetItem(list, 1, PyFloat\_FromDouble(right));}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2038     PyTuple\_SetItem(args, 0, list);}
\DoxyCodeLine{2039 }
\DoxyCodeLine{2040     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_ylim, args);}
\DoxyCodeLine{2041     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to ylim() failed."{}});}
\DoxyCodeLine{2042 }
\DoxyCodeLine{2043     Py\_DECREF(args);}
\DoxyCodeLine{2044     Py\_DECREF(res);}
\DoxyCodeLine{2045 \}}
\DoxyCodeLine{2046 }
\DoxyCodeLine{2047 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2048 \textcolor{keywordtype}{void} xlim(Numeric left, Numeric right)}
\DoxyCodeLine{2049 \{}
\DoxyCodeLine{2050     detail::\_interpreter::get();}
\DoxyCodeLine{2051 }
\DoxyCodeLine{2052     PyObject* list = PyList\_New(2);}
\DoxyCodeLine{2053     PyList\_SetItem(list, 0, PyFloat\_FromDouble(left));}
\DoxyCodeLine{2054     PyList\_SetItem(list, 1, PyFloat\_FromDouble(right));}
\DoxyCodeLine{2055 }
\DoxyCodeLine{2056     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2057     PyTuple\_SetItem(args, 0, list);}
\DoxyCodeLine{2058 }
\DoxyCodeLine{2059     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_xlim, args);}
\DoxyCodeLine{2060     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to xlim() failed."{}});}
\DoxyCodeLine{2061 }
\DoxyCodeLine{2062     Py\_DECREF(args);}
\DoxyCodeLine{2063     Py\_DECREF(res);}
\DoxyCodeLine{2064 \}}
\DoxyCodeLine{2065 }
\DoxyCodeLine{2066 }
\DoxyCodeLine{2067 \textcolor{keyword}{inline} std::array<double, 2> xlim()}
\DoxyCodeLine{2068 \{}
\DoxyCodeLine{2069     PyObject* args = PyTuple\_New(0);}
\DoxyCodeLine{2070     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_xlim, args);}
\DoxyCodeLine{2071 }
\DoxyCodeLine{2072     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to xlim() failed."{}});}
\DoxyCodeLine{2073 }
\DoxyCodeLine{2074     Py\_DECREF(res);}
\DoxyCodeLine{2075 }
\DoxyCodeLine{2076     PyObject* left = PyTuple\_GetItem(res,0);}
\DoxyCodeLine{2077     PyObject* right = PyTuple\_GetItem(res,1);}
\DoxyCodeLine{2078     \textcolor{keywordflow}{return} \{ PyFloat\_AsDouble(left), PyFloat\_AsDouble(right) \};}
\DoxyCodeLine{2079 \}}
\DoxyCodeLine{2080 }
\DoxyCodeLine{2081 }
\DoxyCodeLine{2082 \textcolor{keyword}{inline} std::array<double, 2> ylim()}
\DoxyCodeLine{2083 \{}
\DoxyCodeLine{2084     PyObject* args = PyTuple\_New(0);}
\DoxyCodeLine{2085     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_ylim, args);}
\DoxyCodeLine{2086 }
\DoxyCodeLine{2087     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to ylim() failed."{}});}
\DoxyCodeLine{2088 }
\DoxyCodeLine{2089     Py\_DECREF(res);}
\DoxyCodeLine{2090 }
\DoxyCodeLine{2091     PyObject* left = PyTuple\_GetItem(res,0);}
\DoxyCodeLine{2092     PyObject* right = PyTuple\_GetItem(res,1);}
\DoxyCodeLine{2093     \textcolor{keywordflow}{return} \{ PyFloat\_AsDouble(left), PyFloat\_AsDouble(right) \};}
\DoxyCodeLine{2094 \}}
\DoxyCodeLine{2095 }
\DoxyCodeLine{2096 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2097 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} xticks(\textcolor{keyword}{const} std::vector<Numeric> \&ticks, \textcolor{keyword}{const} std::vector<std::string> \&labels = \{\}, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{2098 \{}
\DoxyCodeLine{2099     assert(labels.size() == 0 || ticks.size() == labels.size());}
\DoxyCodeLine{2100 }
\DoxyCodeLine{2101     detail::\_interpreter::get();}
\DoxyCodeLine{2102 }
\DoxyCodeLine{2103     \textcolor{comment}{// using numpy array}}
\DoxyCodeLine{2104     PyObject* ticksarray = detail::get\_array(ticks);}
\DoxyCodeLine{2105 }
\DoxyCodeLine{2106     PyObject* args;}
\DoxyCodeLine{2107     \textcolor{keywordflow}{if}(labels.size() == 0) \{}
\DoxyCodeLine{2108         \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2109         args = PyTuple\_New(1);}
\DoxyCodeLine{2110         PyTuple\_SetItem(args, 0, ticksarray);}
\DoxyCodeLine{2111     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2112         \textcolor{comment}{// make tuple of tick labels}}
\DoxyCodeLine{2113         PyObject* labelstuple = PyTuple\_New(labels.size());}
\DoxyCodeLine{2114         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < labels.size(); i++)}
\DoxyCodeLine{2115             PyTuple\_SetItem(labelstuple, i, PyUnicode\_FromString(labels[i].c\_str()));}
\DoxyCodeLine{2116 }
\DoxyCodeLine{2117         \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2118         args = PyTuple\_New(2);}
\DoxyCodeLine{2119         PyTuple\_SetItem(args, 0, ticksarray);}
\DoxyCodeLine{2120         PyTuple\_SetItem(args, 1, labelstuple);}
\DoxyCodeLine{2121     \}}
\DoxyCodeLine{2122 }
\DoxyCodeLine{2123     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2124     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2125     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{2126     \{}
\DoxyCodeLine{2127         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2128     \}}
\DoxyCodeLine{2129 }
\DoxyCodeLine{2130     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_xticks, args, kwargs);}
\DoxyCodeLine{2131 }
\DoxyCodeLine{2132     Py\_DECREF(args);}
\DoxyCodeLine{2133     Py\_DECREF(kwargs);}
\DoxyCodeLine{2134     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to xticks() failed"{}});}
\DoxyCodeLine{2135 }
\DoxyCodeLine{2136     Py\_DECREF(res);}
\DoxyCodeLine{2137 \}}
\DoxyCodeLine{2138 }
\DoxyCodeLine{2139 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2140 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} xticks(\textcolor{keyword}{const} std::vector<Numeric> \&ticks, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{2141 \{}
\DoxyCodeLine{2142     xticks(ticks, \{\}, keywords);}
\DoxyCodeLine{2143 \}}
\DoxyCodeLine{2144 }
\DoxyCodeLine{2145 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2146 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} yticks(\textcolor{keyword}{const} std::vector<Numeric> \&ticks, \textcolor{keyword}{const} std::vector<std::string> \&labels = \{\}, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{2147 \{}
\DoxyCodeLine{2148     assert(labels.size() == 0 || ticks.size() == labels.size());}
\DoxyCodeLine{2149 }
\DoxyCodeLine{2150     detail::\_interpreter::get();}
\DoxyCodeLine{2151 }
\DoxyCodeLine{2152     \textcolor{comment}{// using numpy array}}
\DoxyCodeLine{2153     PyObject* ticksarray = detail::get\_array(ticks);}
\DoxyCodeLine{2154 }
\DoxyCodeLine{2155     PyObject* args;}
\DoxyCodeLine{2156     \textcolor{keywordflow}{if}(labels.size() == 0) \{}
\DoxyCodeLine{2157         \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2158         args = PyTuple\_New(1);}
\DoxyCodeLine{2159         PyTuple\_SetItem(args, 0, ticksarray);}
\DoxyCodeLine{2160     \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2161         \textcolor{comment}{// make tuple of tick labels}}
\DoxyCodeLine{2162         PyObject* labelstuple = PyTuple\_New(labels.size());}
\DoxyCodeLine{2163         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < labels.size(); i++)}
\DoxyCodeLine{2164             PyTuple\_SetItem(labelstuple, i, PyUnicode\_FromString(labels[i].c\_str()));}
\DoxyCodeLine{2165 }
\DoxyCodeLine{2166         \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2167         args = PyTuple\_New(2);}
\DoxyCodeLine{2168         PyTuple\_SetItem(args, 0, ticksarray);}
\DoxyCodeLine{2169         PyTuple\_SetItem(args, 1, labelstuple);}
\DoxyCodeLine{2170     \}}
\DoxyCodeLine{2171 }
\DoxyCodeLine{2172     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2173     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2174     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{2175     \{}
\DoxyCodeLine{2176         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2177     \}}
\DoxyCodeLine{2178 }
\DoxyCodeLine{2179     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_yticks, args, kwargs);}
\DoxyCodeLine{2180 }
\DoxyCodeLine{2181     Py\_DECREF(args);}
\DoxyCodeLine{2182     Py\_DECREF(kwargs);}
\DoxyCodeLine{2183     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to yticks() failed"{}});}
\DoxyCodeLine{2184 }
\DoxyCodeLine{2185     Py\_DECREF(res);}
\DoxyCodeLine{2186 \}}
\DoxyCodeLine{2187 }
\DoxyCodeLine{2188 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2189 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} yticks(\textcolor{keyword}{const} std::vector<Numeric> \&ticks, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords)}
\DoxyCodeLine{2190 \{}
\DoxyCodeLine{2191     yticks(ticks, \{\}, keywords);}
\DoxyCodeLine{2192 \}}
\DoxyCodeLine{2193 }
\DoxyCodeLine{2194 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} margins(Numeric margin)}
\DoxyCodeLine{2195 \{}
\DoxyCodeLine{2196     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2197     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2198     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(margin));}
\DoxyCodeLine{2199 }
\DoxyCodeLine{2200     PyObject* res =}
\DoxyCodeLine{2201             PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_margins, args);}
\DoxyCodeLine{2202     \textcolor{keywordflow}{if} (!res)}
\DoxyCodeLine{2203         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to margins() failed."{}});}
\DoxyCodeLine{2204 }
\DoxyCodeLine{2205     Py\_DECREF(args);}
\DoxyCodeLine{2206     Py\_DECREF(res);}
\DoxyCodeLine{2207 \}}
\DoxyCodeLine{2208 }
\DoxyCodeLine{2209 \textcolor{keyword}{template} <\textcolor{keyword}{typename} Numeric> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} margins(Numeric margin\_x, Numeric margin\_y)}
\DoxyCodeLine{2210 \{}
\DoxyCodeLine{2211     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2212     PyObject* args = PyTuple\_New(2);}
\DoxyCodeLine{2213     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(margin\_x));}
\DoxyCodeLine{2214     PyTuple\_SetItem(args, 1, PyFloat\_FromDouble(margin\_y));}
\DoxyCodeLine{2215 }
\DoxyCodeLine{2216     PyObject* res =}
\DoxyCodeLine{2217             PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_margins, args);}
\DoxyCodeLine{2218     \textcolor{keywordflow}{if} (!res)}
\DoxyCodeLine{2219         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to margins() failed."{}});}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2221     Py\_DECREF(args);}
\DoxyCodeLine{2222     Py\_DECREF(res);}
\DoxyCodeLine{2223 \}}
\DoxyCodeLine{2224 }
\DoxyCodeLine{2225 }
\DoxyCodeLine{2226 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} tick\_params(\textcolor{keyword}{const} std::map<std::string, std::string>\& keywords, \textcolor{keyword}{const} std::string axis = \textcolor{stringliteral}{"{}both"{}})}
\DoxyCodeLine{2227 \{}
\DoxyCodeLine{2228   detail::\_interpreter::get();}
\DoxyCodeLine{2229 }
\DoxyCodeLine{2230   \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2231   PyObject* args;}
\DoxyCodeLine{2232   args = PyTuple\_New(1);}
\DoxyCodeLine{2233   PyTuple\_SetItem(args, 0, PyString\_FromString(axis.c\_str()));}
\DoxyCodeLine{2234 }
\DoxyCodeLine{2235   \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2236   PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2237   \textcolor{keywordflow}{for} (std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{2238   \{}
\DoxyCodeLine{2239     PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2240   \}}
\DoxyCodeLine{2241 }
\DoxyCodeLine{2242 }
\DoxyCodeLine{2243   PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_tick\_params, args, kwargs);}
\DoxyCodeLine{2244 }
\DoxyCodeLine{2245   Py\_DECREF(args);}
\DoxyCodeLine{2246   Py\_DECREF(kwargs);}
\DoxyCodeLine{2247   \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to tick\_params() failed"{}});}
\DoxyCodeLine{2248 }
\DoxyCodeLine{2249   Py\_DECREF(res);}
\DoxyCodeLine{2250 \}}
\DoxyCodeLine{2251 }
\DoxyCodeLine{2252 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} subplot(\textcolor{keywordtype}{long} nrows, \textcolor{keywordtype}{long} ncols, \textcolor{keywordtype}{long} plot\_number)}
\DoxyCodeLine{2253 \{}
\DoxyCodeLine{2254     detail::\_interpreter::get();}
\DoxyCodeLine{2255 }
\DoxyCodeLine{2256     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2257     PyObject* args = PyTuple\_New(3);}
\DoxyCodeLine{2258     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(nrows));}
\DoxyCodeLine{2259     PyTuple\_SetItem(args, 1, PyFloat\_FromDouble(ncols));}
\DoxyCodeLine{2260     PyTuple\_SetItem(args, 2, PyFloat\_FromDouble(plot\_number));}
\DoxyCodeLine{2261 }
\DoxyCodeLine{2262     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_subplot, args);}
\DoxyCodeLine{2263     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to subplot() failed."{}});}
\DoxyCodeLine{2264 }
\DoxyCodeLine{2265     Py\_DECREF(args);}
\DoxyCodeLine{2266     Py\_DECREF(res);}
\DoxyCodeLine{2267 \}}
\DoxyCodeLine{2268 }
\DoxyCodeLine{2269 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} subplot2grid(\textcolor{keywordtype}{long} nrows, \textcolor{keywordtype}{long} ncols, \textcolor{keywordtype}{long} rowid=0, \textcolor{keywordtype}{long} colid=0, \textcolor{keywordtype}{long} rowspan=1, \textcolor{keywordtype}{long} colspan=1)}
\DoxyCodeLine{2270 \{}
\DoxyCodeLine{2271     detail::\_interpreter::get();}
\DoxyCodeLine{2272 }
\DoxyCodeLine{2273     PyObject* shape = PyTuple\_New(2);}
\DoxyCodeLine{2274     PyTuple\_SetItem(shape, 0, PyLong\_FromLong(nrows));}
\DoxyCodeLine{2275     PyTuple\_SetItem(shape, 1, PyLong\_FromLong(ncols));}
\DoxyCodeLine{2276 }
\DoxyCodeLine{2277     PyObject* loc = PyTuple\_New(2);}
\DoxyCodeLine{2278     PyTuple\_SetItem(loc, 0, PyLong\_FromLong(rowid));}
\DoxyCodeLine{2279     PyTuple\_SetItem(loc, 1, PyLong\_FromLong(colid));}
\DoxyCodeLine{2280 }
\DoxyCodeLine{2281     PyObject* args = PyTuple\_New(4);}
\DoxyCodeLine{2282     PyTuple\_SetItem(args, 0, shape);}
\DoxyCodeLine{2283     PyTuple\_SetItem(args, 1, loc);}
\DoxyCodeLine{2284     PyTuple\_SetItem(args, 2, PyLong\_FromLong(rowspan));}
\DoxyCodeLine{2285     PyTuple\_SetItem(args, 3, PyLong\_FromLong(colspan));}
\DoxyCodeLine{2286 }
\DoxyCodeLine{2287     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_subplot2grid, args);}
\DoxyCodeLine{2288     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to subplot2grid() failed."{}});}
\DoxyCodeLine{2289 }
\DoxyCodeLine{2290     Py\_DECREF(shape);}
\DoxyCodeLine{2291     Py\_DECREF(loc);}
\DoxyCodeLine{2292     Py\_DECREF(args);}
\DoxyCodeLine{2293     Py\_DECREF(res);}
\DoxyCodeLine{2294 \}}
\DoxyCodeLine{2295 }
\DoxyCodeLine{2296 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} title(\textcolor{keyword}{const} std::string \&titlestr, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{2297 \{}
\DoxyCodeLine{2298     detail::\_interpreter::get();}
\DoxyCodeLine{2299 }
\DoxyCodeLine{2300     PyObject* pytitlestr = PyString\_FromString(titlestr.c\_str());}
\DoxyCodeLine{2301     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2302     PyTuple\_SetItem(args, 0, pytitlestr);}
\DoxyCodeLine{2303 }
\DoxyCodeLine{2304     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2305     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2306         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2307     \}}
\DoxyCodeLine{2308 }
\DoxyCodeLine{2309     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_title, args, kwargs);}
\DoxyCodeLine{2310     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to title() failed."{}});}
\DoxyCodeLine{2311 }
\DoxyCodeLine{2312     Py\_DECREF(args);}
\DoxyCodeLine{2313     Py\_DECREF(kwargs);}
\DoxyCodeLine{2314     Py\_DECREF(res);}
\DoxyCodeLine{2315 \}}
\DoxyCodeLine{2316 }
\DoxyCodeLine{2317 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} suptitle(\textcolor{keyword}{const} std::string \&suptitlestr, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{2318 \{}
\DoxyCodeLine{2319     detail::\_interpreter::get();}
\DoxyCodeLine{2320 }
\DoxyCodeLine{2321     PyObject* pysuptitlestr = PyString\_FromString(suptitlestr.c\_str());}
\DoxyCodeLine{2322     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2323     PyTuple\_SetItem(args, 0, pysuptitlestr);}
\DoxyCodeLine{2324 }
\DoxyCodeLine{2325     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2326     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2327         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2328     \}}
\DoxyCodeLine{2329 }
\DoxyCodeLine{2330     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_suptitle, args, kwargs);}
\DoxyCodeLine{2331     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to suptitle() failed."{}});}
\DoxyCodeLine{2332 }
\DoxyCodeLine{2333     Py\_DECREF(args);}
\DoxyCodeLine{2334     Py\_DECREF(kwargs);}
\DoxyCodeLine{2335     Py\_DECREF(res);}
\DoxyCodeLine{2336 \}}
\DoxyCodeLine{2337 }
\DoxyCodeLine{2338 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axis(\textcolor{keyword}{const} std::string \&axisstr)}
\DoxyCodeLine{2339 \{}
\DoxyCodeLine{2340     detail::\_interpreter::get();}
\DoxyCodeLine{2341 }
\DoxyCodeLine{2342     PyObject* str = PyString\_FromString(axisstr.c\_str());}
\DoxyCodeLine{2343     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2344     PyTuple\_SetItem(args, 0, str);}
\DoxyCodeLine{2345 }
\DoxyCodeLine{2346     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_axis, args);}
\DoxyCodeLine{2347     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to title() failed."{}});}
\DoxyCodeLine{2348 }
\DoxyCodeLine{2349     Py\_DECREF(args);}
\DoxyCodeLine{2350     Py\_DECREF(res);}
\DoxyCodeLine{2351 \}}
\DoxyCodeLine{2352 }
\DoxyCodeLine{2353 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axhline(\textcolor{keywordtype}{double} y, \textcolor{keywordtype}{double} xmin = 0., \textcolor{keywordtype}{double} xmax = 1., \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = std::map<std::string, std::string>())}
\DoxyCodeLine{2354 \{}
\DoxyCodeLine{2355     detail::\_interpreter::get();}
\DoxyCodeLine{2356 }
\DoxyCodeLine{2357     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2358     PyObject* args = PyTuple\_New(3);}
\DoxyCodeLine{2359     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(y));}
\DoxyCodeLine{2360     PyTuple\_SetItem(args, 1, PyFloat\_FromDouble(xmin));}
\DoxyCodeLine{2361     PyTuple\_SetItem(args, 2, PyFloat\_FromDouble(xmax));}
\DoxyCodeLine{2362 }
\DoxyCodeLine{2363     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2364     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2365     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{2366     \{}
\DoxyCodeLine{2367         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2368     \}}
\DoxyCodeLine{2369 }
\DoxyCodeLine{2370     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_axhline, args, kwargs);}
\DoxyCodeLine{2371 }
\DoxyCodeLine{2372     Py\_DECREF(args);}
\DoxyCodeLine{2373     Py\_DECREF(kwargs);}
\DoxyCodeLine{2374 }
\DoxyCodeLine{2375     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{2376 \}}
\DoxyCodeLine{2377 }
\DoxyCodeLine{2378 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axvline(\textcolor{keywordtype}{double} x, \textcolor{keywordtype}{double} ymin = 0., \textcolor{keywordtype}{double} ymax = 1., \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = std::map<std::string, std::string>())}
\DoxyCodeLine{2379 \{}
\DoxyCodeLine{2380     detail::\_interpreter::get();}
\DoxyCodeLine{2381 }
\DoxyCodeLine{2382     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2383     PyObject* args = PyTuple\_New(3);}
\DoxyCodeLine{2384     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(x));}
\DoxyCodeLine{2385     PyTuple\_SetItem(args, 1, PyFloat\_FromDouble(ymin));}
\DoxyCodeLine{2386     PyTuple\_SetItem(args, 2, PyFloat\_FromDouble(ymax));}
\DoxyCodeLine{2387 }
\DoxyCodeLine{2388     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2389     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2390     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{2391     \{}
\DoxyCodeLine{2392         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2393     \}}
\DoxyCodeLine{2394 }
\DoxyCodeLine{2395     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_axvline, args, kwargs);}
\DoxyCodeLine{2396 }
\DoxyCodeLine{2397     Py\_DECREF(args);}
\DoxyCodeLine{2398     Py\_DECREF(kwargs);}
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{2401 \}}
\DoxyCodeLine{2402 }
\DoxyCodeLine{2403 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} axvspan(\textcolor{keywordtype}{double} xmin, \textcolor{keywordtype}{double} xmax, \textcolor{keywordtype}{double} ymin = 0., \textcolor{keywordtype}{double} ymax = 1., \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = std::map<std::string, std::string>())}
\DoxyCodeLine{2404 \{}
\DoxyCodeLine{2405     \textcolor{comment}{// construct positional args}}
\DoxyCodeLine{2406     PyObject* args = PyTuple\_New(4);}
\DoxyCodeLine{2407     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(xmin));}
\DoxyCodeLine{2408     PyTuple\_SetItem(args, 1, PyFloat\_FromDouble(xmax));}
\DoxyCodeLine{2409     PyTuple\_SetItem(args, 2, PyFloat\_FromDouble(ymin));}
\DoxyCodeLine{2410     PyTuple\_SetItem(args, 3, PyFloat\_FromDouble(ymax));}
\DoxyCodeLine{2411 }
\DoxyCodeLine{2412     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2413     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2414     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2415       \textcolor{keywordflow}{if} (it-\/>first == \textcolor{stringliteral}{"{}linewidth"{}} || it-\/>first == \textcolor{stringliteral}{"{}alpha"{}}) \{}
\DoxyCodeLine{2416         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{2417           PyFloat\_FromDouble(std::stod(it-\/>second)));}
\DoxyCodeLine{2418       \} \textcolor{keywordflow}{else} \{}
\DoxyCodeLine{2419         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(),}
\DoxyCodeLine{2420           PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2421       \}}
\DoxyCodeLine{2422     \}}
\DoxyCodeLine{2423 }
\DoxyCodeLine{2424     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_axvspan, args, kwargs);}
\DoxyCodeLine{2425     Py\_DECREF(args);}
\DoxyCodeLine{2426     Py\_DECREF(kwargs);}
\DoxyCodeLine{2427 }
\DoxyCodeLine{2428     \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{2429 \}}
\DoxyCodeLine{2430 }
\DoxyCodeLine{2431 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} xlabel(\textcolor{keyword}{const} std::string \&str, \textcolor{keyword}{const} std::map<std::string, std::string> \&keywords = \{\})}
\DoxyCodeLine{2432 \{}
\DoxyCodeLine{2433     detail::\_interpreter::get();}
\DoxyCodeLine{2434 }
\DoxyCodeLine{2435     PyObject* pystr = PyString\_FromString(str.c\_str());}
\DoxyCodeLine{2436     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2437     PyTuple\_SetItem(args, 0, pystr);}
\DoxyCodeLine{2438 }
\DoxyCodeLine{2439     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2440     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2441         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2442     \}}
\DoxyCodeLine{2443 }
\DoxyCodeLine{2444     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_xlabel, args, kwargs);}
\DoxyCodeLine{2445     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to xlabel() failed."{}});}
\DoxyCodeLine{2446 }
\DoxyCodeLine{2447     Py\_DECREF(args);}
\DoxyCodeLine{2448     Py\_DECREF(kwargs);}
\DoxyCodeLine{2449     Py\_DECREF(res);}
\DoxyCodeLine{2450 \}}
\DoxyCodeLine{2451 }
\DoxyCodeLine{2452 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} ylabel(\textcolor{keyword}{const} std::string \&str, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{2453 \{}
\DoxyCodeLine{2454     detail::\_interpreter::get();}
\DoxyCodeLine{2455 }
\DoxyCodeLine{2456     PyObject* pystr = PyString\_FromString(str.c\_str());}
\DoxyCodeLine{2457     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2458     PyTuple\_SetItem(args, 0, pystr);}
\DoxyCodeLine{2459 }
\DoxyCodeLine{2460     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2461     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2462         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2463     \}}
\DoxyCodeLine{2464 }
\DoxyCodeLine{2465     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_ylabel, args, kwargs);}
\DoxyCodeLine{2466     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to ylabel() failed."{}});}
\DoxyCodeLine{2467 }
\DoxyCodeLine{2468     Py\_DECREF(args);}
\DoxyCodeLine{2469     Py\_DECREF(kwargs);}
\DoxyCodeLine{2470     Py\_DECREF(res);}
\DoxyCodeLine{2471 \}}
\DoxyCodeLine{2472 }
\DoxyCodeLine{2473 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} set\_zlabel(\textcolor{keyword}{const} std::string \&str, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{2474 \{}
\DoxyCodeLine{2475     detail::\_interpreter::get();}
\DoxyCodeLine{2476 }
\DoxyCodeLine{2477     \textcolor{comment}{// Same as with plot\_surface: We lazily load the modules here the first time}}
\DoxyCodeLine{2478     \textcolor{comment}{// this function is called because I'm not sure that we can assume "{}matplotlib}}
\DoxyCodeLine{2479     \textcolor{comment}{// installed"{} implies "{}mpl\_toolkits installed"{} on all platforms, and we don't}}
\DoxyCodeLine{2480     \textcolor{comment}{// want to require it for people who don't need 3d plots.}}
\DoxyCodeLine{2481     \textcolor{keyword}{static} PyObject *mpl\_toolkitsmod = \textcolor{keyword}{nullptr}, *axis3dmod = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2482     \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{}
\DoxyCodeLine{2483         PyObject* mpl\_toolkits = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits"{}});}
\DoxyCodeLine{2484         PyObject* axis3d = PyString\_FromString(\textcolor{stringliteral}{"{}mpl\_toolkits.mplot3d"{}});}
\DoxyCodeLine{2485         \textcolor{keywordflow}{if} (!mpl\_toolkits || !axis3d) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}couldnt create string"{}}); \}}
\DoxyCodeLine{2486 }
\DoxyCodeLine{2487         mpl\_toolkitsmod = PyImport\_Import(mpl\_toolkits);}
\DoxyCodeLine{2488         Py\_DECREF(mpl\_toolkits);}
\DoxyCodeLine{2489         \textcolor{keywordflow}{if} (!mpl\_toolkitsmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits!"{}}); \}}
\DoxyCodeLine{2490 }
\DoxyCodeLine{2491         axis3dmod = PyImport\_Import(axis3d);}
\DoxyCodeLine{2492         Py\_DECREF(axis3d);}
\DoxyCodeLine{2493         \textcolor{keywordflow}{if} (!axis3dmod) \{ \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Error loading module mpl\_toolkits.mplot3d!"{}}); \}}
\DoxyCodeLine{2494     \}}
\DoxyCodeLine{2495 }
\DoxyCodeLine{2496     PyObject* pystr = PyString\_FromString(str.c\_str());}
\DoxyCodeLine{2497     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2498     PyTuple\_SetItem(args, 0, pystr);}
\DoxyCodeLine{2499 }
\DoxyCodeLine{2500     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2501     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2502         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2503     \}}
\DoxyCodeLine{2504 }
\DoxyCodeLine{2505     PyObject *ax =}
\DoxyCodeLine{2506     PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_gca,}
\DoxyCodeLine{2507       detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2508     \textcolor{keywordflow}{if} (!ax) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to gca() failed."{}});}
\DoxyCodeLine{2509     Py\_INCREF(ax);}
\DoxyCodeLine{2510 }
\DoxyCodeLine{2511     PyObject *zlabel = PyObject\_GetAttrString(ax, \textcolor{stringliteral}{"{}set\_zlabel"{}});}
\DoxyCodeLine{2512     \textcolor{keywordflow}{if} (!zlabel) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Attribute set\_zlabel not found."{}});}
\DoxyCodeLine{2513     Py\_INCREF(zlabel);}
\DoxyCodeLine{2514 }
\DoxyCodeLine{2515     PyObject *res = PyObject\_Call(zlabel, args, kwargs);}
\DoxyCodeLine{2516     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to set\_zlabel() failed."{}});}
\DoxyCodeLine{2517     Py\_DECREF(zlabel);}
\DoxyCodeLine{2518 }
\DoxyCodeLine{2519     Py\_DECREF(ax);}
\DoxyCodeLine{2520     Py\_DECREF(args);}
\DoxyCodeLine{2521     Py\_DECREF(kwargs);}
\DoxyCodeLine{2522     \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{2523 \}}
\DoxyCodeLine{2524 }
\DoxyCodeLine{2525 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} grid(\textcolor{keywordtype}{bool} flag)}
\DoxyCodeLine{2526 \{}
\DoxyCodeLine{2527     detail::\_interpreter::get();}
\DoxyCodeLine{2528 }
\DoxyCodeLine{2529     PyObject* pyflag = flag ? Py\_True : Py\_False;}
\DoxyCodeLine{2530     Py\_INCREF(pyflag);}
\DoxyCodeLine{2531 }
\DoxyCodeLine{2532     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2533     PyTuple\_SetItem(args, 0, pyflag);}
\DoxyCodeLine{2534 }
\DoxyCodeLine{2535     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_grid, args);}
\DoxyCodeLine{2536     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to grid() failed."{}});}
\DoxyCodeLine{2537 }
\DoxyCodeLine{2538     Py\_DECREF(args);}
\DoxyCodeLine{2539     Py\_DECREF(res);}
\DoxyCodeLine{2540 \}}
\DoxyCodeLine{2541 }
\DoxyCodeLine{2542 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} show(\textcolor{keyword}{const} \textcolor{keywordtype}{bool} block = \textcolor{keyword}{true})}
\DoxyCodeLine{2543 \{}
\DoxyCodeLine{2544     detail::\_interpreter::get();}
\DoxyCodeLine{2545 }
\DoxyCodeLine{2546     PyObject* res;}
\DoxyCodeLine{2547     \textcolor{keywordflow}{if}(block)}
\DoxyCodeLine{2548     \{}
\DoxyCodeLine{2549         res = PyObject\_CallObject(}
\DoxyCodeLine{2550                 detail::\_interpreter::get().s\_python\_function\_show,}
\DoxyCodeLine{2551                 detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2552     \}}
\DoxyCodeLine{2553     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2554     \{}
\DoxyCodeLine{2555         PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{2556         PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}block"{}}, Py\_False);}
\DoxyCodeLine{2557         res = PyObject\_Call( detail::\_interpreter::get().s\_python\_function\_show, detail::\_interpreter::get().s\_python\_empty\_tuple, kwargs);}
\DoxyCodeLine{2558        Py\_DECREF(kwargs);}
\DoxyCodeLine{2559     \}}
\DoxyCodeLine{2560 }
\DoxyCodeLine{2561 }
\DoxyCodeLine{2562     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to show() failed."{}});}
\DoxyCodeLine{2563 }
\DoxyCodeLine{2564     Py\_DECREF(res);}
\DoxyCodeLine{2565 \}}
\DoxyCodeLine{2566 }
\DoxyCodeLine{2567 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} close()}
\DoxyCodeLine{2568 \{}
\DoxyCodeLine{2569     detail::\_interpreter::get();}
\DoxyCodeLine{2570 }
\DoxyCodeLine{2571     PyObject* res = PyObject\_CallObject(}
\DoxyCodeLine{2572             detail::\_interpreter::get().s\_python\_function\_close,}
\DoxyCodeLine{2573             detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2574 }
\DoxyCodeLine{2575     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to close() failed."{}});}
\DoxyCodeLine{2576 }
\DoxyCodeLine{2577     Py\_DECREF(res);}
\DoxyCodeLine{2578 \}}
\DoxyCodeLine{2579 }
\DoxyCodeLine{2580 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} xkcd() \{}
\DoxyCodeLine{2581     detail::\_interpreter::get();}
\DoxyCodeLine{2582 }
\DoxyCodeLine{2583     PyObject* res;}
\DoxyCodeLine{2584     PyObject *kwargs = PyDict\_New();}
\DoxyCodeLine{2585 }
\DoxyCodeLine{2586     res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_xkcd,}
\DoxyCodeLine{2587             detail::\_interpreter::get().s\_python\_empty\_tuple, kwargs);}
\DoxyCodeLine{2588 }
\DoxyCodeLine{2589     Py\_DECREF(kwargs);}
\DoxyCodeLine{2590 }
\DoxyCodeLine{2591     \textcolor{keywordflow}{if} (!res)}
\DoxyCodeLine{2592         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to show() failed."{}});}
\DoxyCodeLine{2593 }
\DoxyCodeLine{2594     Py\_DECREF(res);}
\DoxyCodeLine{2595 \}}
\DoxyCodeLine{2596 }
\DoxyCodeLine{2597 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} draw()}
\DoxyCodeLine{2598 \{}
\DoxyCodeLine{2599     detail::\_interpreter::get();}
\DoxyCodeLine{2600 }
\DoxyCodeLine{2601     PyObject* res = PyObject\_CallObject(}
\DoxyCodeLine{2602         detail::\_interpreter::get().s\_python\_function\_draw,}
\DoxyCodeLine{2603         detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2604 }
\DoxyCodeLine{2605     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to draw() failed."{}});}
\DoxyCodeLine{2606 }
\DoxyCodeLine{2607     Py\_DECREF(res);}
\DoxyCodeLine{2608 \}}
\DoxyCodeLine{2609 }
\DoxyCodeLine{2610 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2611 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} pause(Numeric interval)}
\DoxyCodeLine{2612 \{}
\DoxyCodeLine{2613     detail::\_interpreter::get();}
\DoxyCodeLine{2614 }
\DoxyCodeLine{2615     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2616     PyTuple\_SetItem(args, 0, PyFloat\_FromDouble(interval));}
\DoxyCodeLine{2617 }
\DoxyCodeLine{2618     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_pause, args);}
\DoxyCodeLine{2619     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to pause() failed."{}});}
\DoxyCodeLine{2620 }
\DoxyCodeLine{2621     Py\_DECREF(args);}
\DoxyCodeLine{2622     Py\_DECREF(res);}
\DoxyCodeLine{2623 \}}
\DoxyCodeLine{2624 }
\DoxyCodeLine{2625 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} save(\textcolor{keyword}{const} std::string\& filename, \textcolor{keyword}{const} \textcolor{keywordtype}{int} dpi=0)}
\DoxyCodeLine{2626 \{}
\DoxyCodeLine{2627     detail::\_interpreter::get();}
\DoxyCodeLine{2628 }
\DoxyCodeLine{2629     PyObject* pyfilename = PyString\_FromString(filename.c\_str());}
\DoxyCodeLine{2630 }
\DoxyCodeLine{2631     PyObject* args = PyTuple\_New(1);}
\DoxyCodeLine{2632     PyTuple\_SetItem(args, 0, pyfilename);}
\DoxyCodeLine{2633 }
\DoxyCodeLine{2634     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2635 }
\DoxyCodeLine{2636     \textcolor{keywordflow}{if}(dpi > 0)}
\DoxyCodeLine{2637     \{}
\DoxyCodeLine{2638         PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}dpi"{}}, PyLong\_FromLong(dpi));}
\DoxyCodeLine{2639     \}}
\DoxyCodeLine{2640 }
\DoxyCodeLine{2641     PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_save, args, kwargs);}
\DoxyCodeLine{2642     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to save() failed."{}});}
\DoxyCodeLine{2643 }
\DoxyCodeLine{2644     Py\_DECREF(args);}
\DoxyCodeLine{2645     Py\_DECREF(kwargs);}
\DoxyCodeLine{2646     Py\_DECREF(res);}
\DoxyCodeLine{2647 \}}
\DoxyCodeLine{2648 }
\DoxyCodeLine{2649 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} rcparams(\textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\}) \{}
\DoxyCodeLine{2650     detail::\_interpreter::get();}
\DoxyCodeLine{2651     PyObject* args = PyTuple\_New(0);}
\DoxyCodeLine{2652     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2653     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = keywords.begin(); it != keywords.end(); ++it) \{}
\DoxyCodeLine{2654         \textcolor{keywordflow}{if} (\textcolor{stringliteral}{"{}text.usetex"{}} == it-\/>first)}
\DoxyCodeLine{2655           PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyLong\_FromLong(std::stoi(it-\/>second.c\_str())));}
\DoxyCodeLine{2656         \textcolor{keywordflow}{else} PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyString\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2657     \}}
\DoxyCodeLine{2658     }
\DoxyCodeLine{2659     PyObject * update = PyObject\_GetAttrString(detail::\_interpreter::get().s\_python\_function\_rcparams, \textcolor{stringliteral}{"{}update"{}});}
\DoxyCodeLine{2660     PyObject * res = PyObject\_Call(update, args, kwargs);}
\DoxyCodeLine{2661     \textcolor{keywordflow}{if}(!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to rcParams.update() failed."{}});}
\DoxyCodeLine{2662     Py\_DECREF(args);}
\DoxyCodeLine{2663     Py\_DECREF(kwargs);}
\DoxyCodeLine{2664     Py\_DECREF(update);}
\DoxyCodeLine{2665     Py\_DECREF(res);}
\DoxyCodeLine{2666 \}}
\DoxyCodeLine{2667 }
\DoxyCodeLine{2668 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} clf() \{}
\DoxyCodeLine{2669     detail::\_interpreter::get();}
\DoxyCodeLine{2670 }
\DoxyCodeLine{2671     PyObject *res = PyObject\_CallObject(}
\DoxyCodeLine{2672         detail::\_interpreter::get().s\_python\_function\_clf,}
\DoxyCodeLine{2673         detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2674 }
\DoxyCodeLine{2675     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to clf() failed."{}});}
\DoxyCodeLine{2676 }
\DoxyCodeLine{2677     Py\_DECREF(res);}
\DoxyCodeLine{2678 \}}
\DoxyCodeLine{2679 }
\DoxyCodeLine{2680 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} cla() \{}
\DoxyCodeLine{2681     detail::\_interpreter::get();}
\DoxyCodeLine{2682 }
\DoxyCodeLine{2683     PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_cla,}
\DoxyCodeLine{2684                                         detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2685 }
\DoxyCodeLine{2686     \textcolor{keywordflow}{if} (!res)}
\DoxyCodeLine{2687         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to cla() failed."{}});}
\DoxyCodeLine{2688 }
\DoxyCodeLine{2689     Py\_DECREF(res);}
\DoxyCodeLine{2690 \}}
\DoxyCodeLine{2691 }
\DoxyCodeLine{2692 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} ion() \{}
\DoxyCodeLine{2693     detail::\_interpreter::get();}
\DoxyCodeLine{2694 }
\DoxyCodeLine{2695     PyObject *res = PyObject\_CallObject(}
\DoxyCodeLine{2696         detail::\_interpreter::get().s\_python\_function\_ion,}
\DoxyCodeLine{2697         detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2698 }
\DoxyCodeLine{2699     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to ion() failed."{}});}
\DoxyCodeLine{2700 }
\DoxyCodeLine{2701     Py\_DECREF(res);}
\DoxyCodeLine{2702 \}}
\DoxyCodeLine{2703 }
\DoxyCodeLine{2704 \textcolor{keyword}{inline} std::vector<std::array<double, 2>> ginput(\textcolor{keyword}{const} \textcolor{keywordtype}{int} numClicks = 1, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords = \{\})}
\DoxyCodeLine{2705 \{}
\DoxyCodeLine{2706     detail::\_interpreter::get();}
\DoxyCodeLine{2707 }
\DoxyCodeLine{2708     PyObject *args = PyTuple\_New(1);}
\DoxyCodeLine{2709     PyTuple\_SetItem(args, 0, PyLong\_FromLong(numClicks));}
\DoxyCodeLine{2710 }
\DoxyCodeLine{2711     \textcolor{comment}{// construct keyword args}}
\DoxyCodeLine{2712     PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2713     \textcolor{keywordflow}{for}(std::map<std::string, std::string>::const\_iterator it = keywords.begin(); it != keywords.end(); ++it)}
\DoxyCodeLine{2714     \{}
\DoxyCodeLine{2715         PyDict\_SetItemString(kwargs, it-\/>first.c\_str(), PyUnicode\_FromString(it-\/>second.c\_str()));}
\DoxyCodeLine{2716     \}}
\DoxyCodeLine{2717 }
\DoxyCodeLine{2718     PyObject* res = PyObject\_Call(}
\DoxyCodeLine{2719         detail::\_interpreter::get().s\_python\_function\_ginput, args, kwargs);}
\DoxyCodeLine{2720 }
\DoxyCodeLine{2721     Py\_DECREF(kwargs);}
\DoxyCodeLine{2722     Py\_DECREF(args);}
\DoxyCodeLine{2723     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to ginput() failed."{}});}
\DoxyCodeLine{2724 }
\DoxyCodeLine{2725     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} len = PyList\_Size(res);}
\DoxyCodeLine{2726     std::vector<std::array<double, 2>> out;}
\DoxyCodeLine{2727     out.reserve(len);}
\DoxyCodeLine{2728     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < len; i++) \{}
\DoxyCodeLine{2729         PyObject *current = PyList\_GetItem(res, i);}
\DoxyCodeLine{2730         std::array<double, 2> position;}
\DoxyCodeLine{2731         position[0] = PyFloat\_AsDouble(PyTuple\_GetItem(current, 0));}
\DoxyCodeLine{2732         position[1] = PyFloat\_AsDouble(PyTuple\_GetItem(current, 1));}
\DoxyCodeLine{2733         out.push\_back(position);}
\DoxyCodeLine{2734     \}}
\DoxyCodeLine{2735     Py\_DECREF(res);}
\DoxyCodeLine{2736 }
\DoxyCodeLine{2737     \textcolor{keywordflow}{return} out;}
\DoxyCodeLine{2738 \}}
\DoxyCodeLine{2739 }
\DoxyCodeLine{2740 \textcolor{comment}{// Actually, is there any reason not to call this automatically for every plot?}}
\DoxyCodeLine{2741 \textcolor{keyword}{inline} \textcolor{keywordtype}{void} tight\_layout() \{}
\DoxyCodeLine{2742     detail::\_interpreter::get();}
\DoxyCodeLine{2743 }
\DoxyCodeLine{2744     PyObject *res = PyObject\_CallObject(}
\DoxyCodeLine{2745         detail::\_interpreter::get().s\_python\_function\_tight\_layout,}
\DoxyCodeLine{2746         detail::\_interpreter::get().s\_python\_empty\_tuple);}
\DoxyCodeLine{2747 }
\DoxyCodeLine{2748     \textcolor{keywordflow}{if} (!res) \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}Call to tight\_layout() failed."{}});}
\DoxyCodeLine{2749 }
\DoxyCodeLine{2750     Py\_DECREF(res);}
\DoxyCodeLine{2751 \}}
\DoxyCodeLine{2752 }
\DoxyCodeLine{2753 \textcolor{comment}{// Support for variadic plot() and initializer lists:}}
\DoxyCodeLine{2754 }
\DoxyCodeLine{2755 \textcolor{keyword}{namespace }detail \{}
\DoxyCodeLine{2756 }
\DoxyCodeLine{2757 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2758 \textcolor{keyword}{using }is\_function = \textcolor{keyword}{typename} std::is\_function<std::remove\_pointer<std::remove\_reference<T>>>::type;}
\DoxyCodeLine{2759 }
\DoxyCodeLine{2760 \textcolor{keyword}{template}<\textcolor{keywordtype}{bool} obj, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{2761 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1is__callable__impl}{is\_callable\_impl}};}
\DoxyCodeLine{2762 }
\DoxyCodeLine{2763 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2764 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1is__callable__impl}{is\_callable\_impl}}<false, T>}
\DoxyCodeLine{2765 \{}
\DoxyCodeLine{2766     \textcolor{keyword}{typedef} is\_function<T> type;}
\DoxyCodeLine{2767 \}; \textcolor{comment}{// a non-\/object is callable iff it is a function}}
\DoxyCodeLine{2768 }
\DoxyCodeLine{2769 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2770 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1is__callable__impl}{is\_callable\_impl}}<true, T>}
\DoxyCodeLine{2771 \{}
\DoxyCodeLine{2772     \textcolor{keyword}{struct }Fallback \{ \textcolor{keywordtype}{void} operator()(); \};}
\DoxyCodeLine{2773     \textcolor{keyword}{struct }Derived : T, Fallback \{ \};}
\DoxyCodeLine{2774 }
\DoxyCodeLine{2775     \textcolor{keyword}{template}<\textcolor{keyword}{typename} U, U> \textcolor{keyword}{struct }Check;}
\DoxyCodeLine{2776 }
\DoxyCodeLine{2777     \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{2778     \textcolor{keyword}{static} std::true\_type test( ... ); \textcolor{comment}{// use a variadic function to make sure (1) it accepts everything and (2) its always the worst match}}
\DoxyCodeLine{2779 }
\DoxyCodeLine{2780     \textcolor{keyword}{template}<\textcolor{keyword}{typename} U>}
\DoxyCodeLine{2781     \textcolor{keyword}{static} std::false\_type test( Check<\textcolor{keywordtype}{void}(Fallback::*)(), \&U::operator()>* );}
\DoxyCodeLine{2782 }
\DoxyCodeLine{2783 \textcolor{keyword}{public}:}
\DoxyCodeLine{2784     \textcolor{keyword}{typedef} \textcolor{keyword}{decltype}(test<Derived>(\textcolor{keyword}{nullptr})) type;}
\DoxyCodeLine{2785     \textcolor{keyword}{typedef} \textcolor{keyword}{decltype}(\&Fallback::operator()) dtype;}
\DoxyCodeLine{2786     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{bool} value = type::value;}
\DoxyCodeLine{2787 \}; \textcolor{comment}{// an object is callable iff it defines operator()}}
\DoxyCodeLine{2788 }
\DoxyCodeLine{2789 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{2790 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1is__callable}{is\_callable}}}
\DoxyCodeLine{2791 \{}
\DoxyCodeLine{2792     \textcolor{comment}{// dispatch to is\_callable\_impl<true, T> or is\_callable\_impl<false, T> depending on whether T is of class type or not}}
\DoxyCodeLine{2793     \textcolor{keyword}{typedef} \textcolor{keyword}{typename} \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1is__callable__impl}{is\_callable\_impl<std::is\_class<T>::value}}, T>::type type;}
\DoxyCodeLine{2794 \};}
\DoxyCodeLine{2795 }
\DoxyCodeLine{2796 \textcolor{keyword}{template}<\textcolor{keyword}{typename} IsYDataCallable>}
\DoxyCodeLine{2797 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1plot__impl}{plot\_impl}} \{ \};}
\DoxyCodeLine{2798 }
\DoxyCodeLine{2799 \textcolor{keyword}{template}<>}
\DoxyCodeLine{2800 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1plot__impl}{plot\_impl}}<std::false\_type>}
\DoxyCodeLine{2801 \{}
\DoxyCodeLine{2802     \textcolor{keyword}{template}<\textcolor{keyword}{typename} IterableX, \textcolor{keyword}{typename} IterableY>}
\DoxyCodeLine{2803     \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} IterableX\& x, \textcolor{keyword}{const} IterableY\& y, \textcolor{keyword}{const} std::string\& format)}
\DoxyCodeLine{2804     \{}
\DoxyCodeLine{2805         detail::\_interpreter::get();}
\DoxyCodeLine{2806 }
\DoxyCodeLine{2807         \textcolor{comment}{// 2-\/phase lookup for distance, begin, end}}
\DoxyCodeLine{2808         \textcolor{keyword}{using }std::distance;}
\DoxyCodeLine{2809         \textcolor{keyword}{using }std::begin;}
\DoxyCodeLine{2810         \textcolor{keyword}{using }std::end;}
\DoxyCodeLine{2811 }
\DoxyCodeLine{2812         \textcolor{keyword}{auto} xs = distance(begin(x), end(x));}
\DoxyCodeLine{2813         \textcolor{keyword}{auto} ys = distance(begin(y), end(y));}
\DoxyCodeLine{2814         assert(xs == ys \&\& \textcolor{stringliteral}{"{}x and y data must have the same number of elements!"{}});}
\DoxyCodeLine{2815 }
\DoxyCodeLine{2816         PyObject* xlist = PyList\_New(xs);}
\DoxyCodeLine{2817         PyObject* ylist = PyList\_New(ys);}
\DoxyCodeLine{2818         PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{2819 }
\DoxyCodeLine{2820         \textcolor{keyword}{auto} itx = begin(x), ity = begin(y);}
\DoxyCodeLine{2821         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} i = 0; i < xs; ++i) \{}
\DoxyCodeLine{2822             PyList\_SetItem(xlist, i, PyFloat\_FromDouble(*itx++));}
\DoxyCodeLine{2823             PyList\_SetItem(ylist, i, PyFloat\_FromDouble(*ity++));}
\DoxyCodeLine{2824         \}}
\DoxyCodeLine{2825 }
\DoxyCodeLine{2826         PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{2827         PyTuple\_SetItem(plot\_args, 0, xlist);}
\DoxyCodeLine{2828         PyTuple\_SetItem(plot\_args, 1, ylist);}
\DoxyCodeLine{2829         PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{2830 }
\DoxyCodeLine{2831         PyObject* res = PyObject\_CallObject(detail::\_interpreter::get().s\_python\_function\_plot, plot\_args);}
\DoxyCodeLine{2832 }
\DoxyCodeLine{2833         Py\_DECREF(plot\_args);}
\DoxyCodeLine{2834         \textcolor{keywordflow}{if}(res) Py\_DECREF(res);}
\DoxyCodeLine{2835 }
\DoxyCodeLine{2836         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{2837     \}}
\DoxyCodeLine{2838 \};}
\DoxyCodeLine{2839 }
\DoxyCodeLine{2840 \textcolor{keyword}{template}<>}
\DoxyCodeLine{2841 \textcolor{keyword}{struct }\mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1plot__impl}{plot\_impl}}<std::true\_type>}
\DoxyCodeLine{2842 \{}
\DoxyCodeLine{2843     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Iterable, \textcolor{keyword}{typename} Callable>}
\DoxyCodeLine{2844     \textcolor{keywordtype}{bool} operator()(\textcolor{keyword}{const} Iterable\& ticks, \textcolor{keyword}{const} Callable\& f, \textcolor{keyword}{const} std::string\& format)}
\DoxyCodeLine{2845     \{}
\DoxyCodeLine{2846         \textcolor{keywordflow}{if}(begin(ticks) == end(ticks)) \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{2847 }
\DoxyCodeLine{2848         \textcolor{comment}{// We could use additional meta-\/programming to deduce the correct element type of y,}}
\DoxyCodeLine{2849         \textcolor{comment}{// but all values have to be convertible to double anyways}}
\DoxyCodeLine{2850         std::vector<double> y;}
\DoxyCodeLine{2851         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} x : ticks) y.push\_back(f(x));}
\DoxyCodeLine{2852         \textcolor{keywordflow}{return} \mbox{\hyperlink{structmatplotlibcpp_1_1detail_1_1plot__impl}{plot\_impl<std::false\_type>}}()(ticks,y,format);}
\DoxyCodeLine{2853     \}}
\DoxyCodeLine{2854 \};}
\DoxyCodeLine{2855 }
\DoxyCodeLine{2856 \} \textcolor{comment}{// end namespace detail}}
\DoxyCodeLine{2857 }
\DoxyCodeLine{2858 \textcolor{comment}{// recursion stop for the above}}
\DoxyCodeLine{2859 \textcolor{keyword}{template}<\textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{2860 \textcolor{keywordtype}{bool} plot() \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}}
\DoxyCodeLine{2861 }
\DoxyCodeLine{2862 \textcolor{keyword}{template}<\textcolor{keyword}{typename} A, \textcolor{keyword}{typename} B, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{2863 \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} A\& a, \textcolor{keyword}{const} B\& b, \textcolor{keyword}{const} std::string\& format, Args... args)}
\DoxyCodeLine{2864 \{}
\DoxyCodeLine{2865     \textcolor{keywordflow}{return} detail::plot\_impl<typename detail::is\_callable<B>::type>()(a,b,format) \&\& plot(args...);}
\DoxyCodeLine{2866 \}}
\DoxyCodeLine{2867 }
\DoxyCodeLine{2868 \textcolor{comment}{/*}}
\DoxyCodeLine{2869 \textcolor{comment}{ * This group of plot() functions is needed to support initializer lists, i.e. calling}}
\DoxyCodeLine{2870 \textcolor{comment}{ *    plot( \{1,2,3,4\} )}}
\DoxyCodeLine{2871 \textcolor{comment}{ */}}
\DoxyCodeLine{2872 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<double>\& x, \textcolor{keyword}{const} std::vector<double>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{2873     \textcolor{keywordflow}{return} plot<double,double>(x,y,format);}
\DoxyCodeLine{2874 \}}
\DoxyCodeLine{2875 }
\DoxyCodeLine{2876 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<double>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{2877     \textcolor{keywordflow}{return} plot<double>(y,format);}
\DoxyCodeLine{2878 \}}
\DoxyCodeLine{2879 }
\DoxyCodeLine{2880 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} plot(\textcolor{keyword}{const} std::vector<double>\& x, \textcolor{keyword}{const} std::vector<double>\& y, \textcolor{keyword}{const} std::map<std::string, std::string>\& keywords) \{}
\DoxyCodeLine{2881     \textcolor{keywordflow}{return} plot<double>(x,y,keywords);}
\DoxyCodeLine{2882 \}}
\DoxyCodeLine{2883 }
\DoxyCodeLine{2884 \textcolor{comment}{/*}}
\DoxyCodeLine{2885 \textcolor{comment}{ * This class allows dynamic plots, ie changing the plotted data without clearing and re-\/plotting}}
\DoxyCodeLine{2886 \textcolor{comment}{ */}}
\DoxyCodeLine{2887 \textcolor{keyword}{class }\mbox{\hyperlink{classmatplotlibcpp_1_1Plot}{Plot}}}
\DoxyCodeLine{2888 \{}
\DoxyCodeLine{2889 \textcolor{keyword}{public}:}
\DoxyCodeLine{2890     \textcolor{comment}{// default initialization with plot label, some data and format}}
\DoxyCodeLine{2891     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2892     \mbox{\hyperlink{classmatplotlibcpp_1_1Plot}{Plot}}(\textcolor{keyword}{const} std::string\& name, \textcolor{keyword}{const} std::vector<Numeric>\& x, \textcolor{keyword}{const} std::vector<Numeric>\& y, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}}) \{}
\DoxyCodeLine{2893         detail::\_interpreter::get();}
\DoxyCodeLine{2894 }
\DoxyCodeLine{2895         assert(x.size() == y.size());}
\DoxyCodeLine{2896 }
\DoxyCodeLine{2897         PyObject* kwargs = PyDict\_New();}
\DoxyCodeLine{2898         \textcolor{keywordflow}{if}(name != \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{2899             PyDict\_SetItemString(kwargs, \textcolor{stringliteral}{"{}label"{}}, PyString\_FromString(name.c\_str()));}
\DoxyCodeLine{2900 }
\DoxyCodeLine{2901         PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{2902         PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{2903 }
\DoxyCodeLine{2904         PyObject* pystring = PyString\_FromString(format.c\_str());}
\DoxyCodeLine{2905 }
\DoxyCodeLine{2906         PyObject* plot\_args = PyTuple\_New(3);}
\DoxyCodeLine{2907         PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{2908         PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{2909         PyTuple\_SetItem(plot\_args, 2, pystring);}
\DoxyCodeLine{2910 }
\DoxyCodeLine{2911         PyObject* res = PyObject\_Call(detail::\_interpreter::get().s\_python\_function\_plot, plot\_args, kwargs);}
\DoxyCodeLine{2912 }
\DoxyCodeLine{2913         Py\_DECREF(kwargs);}
\DoxyCodeLine{2914         Py\_DECREF(plot\_args);}
\DoxyCodeLine{2915 }
\DoxyCodeLine{2916         \textcolor{keywordflow}{if}(res)}
\DoxyCodeLine{2917         \{}
\DoxyCodeLine{2918             line= PyList\_GetItem(res, 0);}
\DoxyCodeLine{2919 }
\DoxyCodeLine{2920             \textcolor{keywordflow}{if}(line)}
\DoxyCodeLine{2921                 set\_data\_fct = PyObject\_GetAttrString(line,\textcolor{stringliteral}{"{}set\_data"{}});}
\DoxyCodeLine{2922             \textcolor{keywordflow}{else}}
\DoxyCodeLine{2923                 Py\_DECREF(line);}
\DoxyCodeLine{2924             Py\_DECREF(res);}
\DoxyCodeLine{2925         \}}
\DoxyCodeLine{2926     \}}
\DoxyCodeLine{2927 }
\DoxyCodeLine{2928     \textcolor{comment}{// shorter initialization with name or format only}}
\DoxyCodeLine{2929     \textcolor{comment}{// basically calls line, = plot([], [])}}
\DoxyCodeLine{2930     \mbox{\hyperlink{classmatplotlibcpp_1_1Plot}{Plot}}(\textcolor{keyword}{const} std::string\& name = \textcolor{stringliteral}{"{}"{}}, \textcolor{keyword}{const} std::string\& format = \textcolor{stringliteral}{"{}"{}})}
\DoxyCodeLine{2931         : \mbox{\hyperlink{classmatplotlibcpp_1_1Plot}{Plot}}(name, std::vector<double>(), std::vector<double>(), format) \{\}}
\DoxyCodeLine{2932 }
\DoxyCodeLine{2933     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Numeric>}
\DoxyCodeLine{2934     \textcolor{keywordtype}{bool} update(\textcolor{keyword}{const} std::vector<Numeric>\& x, \textcolor{keyword}{const} std::vector<Numeric>\& y) \{}
\DoxyCodeLine{2935         assert(x.size() == y.size());}
\DoxyCodeLine{2936         \textcolor{keywordflow}{if}(set\_data\_fct)}
\DoxyCodeLine{2937         \{}
\DoxyCodeLine{2938             PyObject* xarray = detail::get\_array(x);}
\DoxyCodeLine{2939             PyObject* yarray = detail::get\_array(y);}
\DoxyCodeLine{2940 }
\DoxyCodeLine{2941             PyObject* plot\_args = PyTuple\_New(2);}
\DoxyCodeLine{2942             PyTuple\_SetItem(plot\_args, 0, xarray);}
\DoxyCodeLine{2943             PyTuple\_SetItem(plot\_args, 1, yarray);}
\DoxyCodeLine{2944 }
\DoxyCodeLine{2945             PyObject* res = PyObject\_CallObject(set\_data\_fct, plot\_args);}
\DoxyCodeLine{2946             \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{2947             \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{2948         \}}
\DoxyCodeLine{2949         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{2950     \}}
\DoxyCodeLine{2951 }
\DoxyCodeLine{2952     \textcolor{comment}{// clears the plot but keep it available}}
\DoxyCodeLine{2953     \textcolor{keywordtype}{bool} clear() \{}
\DoxyCodeLine{2954         \textcolor{keywordflow}{return} update(std::vector<double>(), std::vector<double>());}
\DoxyCodeLine{2955     \}}
\DoxyCodeLine{2956 }
\DoxyCodeLine{2957     \textcolor{comment}{// definitely remove this line}}
\DoxyCodeLine{2958     \textcolor{keywordtype}{void} remove() \{}
\DoxyCodeLine{2959         \textcolor{keywordflow}{if}(line)}
\DoxyCodeLine{2960         \{}
\DoxyCodeLine{2961             \textcolor{keyword}{auto} remove\_fct = PyObject\_GetAttrString(line,\textcolor{stringliteral}{"{}remove"{}});}
\DoxyCodeLine{2962             PyObject* args = PyTuple\_New(0);}
\DoxyCodeLine{2963             PyObject* res = PyObject\_CallObject(remove\_fct, args);}
\DoxyCodeLine{2964             \textcolor{keywordflow}{if} (res) Py\_DECREF(res);}
\DoxyCodeLine{2965         \}}
\DoxyCodeLine{2966         decref();}
\DoxyCodeLine{2967     \}}
\DoxyCodeLine{2968 }
\DoxyCodeLine{2969     \mbox{\hyperlink{classmatplotlibcpp_1_1Plot}{\string~Plot}}() \{}
\DoxyCodeLine{2970         decref();}
\DoxyCodeLine{2971     \}}
\DoxyCodeLine{2972 \textcolor{keyword}{private}:}
\DoxyCodeLine{2973 }
\DoxyCodeLine{2974     \textcolor{keywordtype}{void} decref() \{}
\DoxyCodeLine{2975         \textcolor{keywordflow}{if}(line)}
\DoxyCodeLine{2976             Py\_DECREF(line);}
\DoxyCodeLine{2977         \textcolor{keywordflow}{if}(set\_data\_fct)}
\DoxyCodeLine{2978             Py\_DECREF(set\_data\_fct);}
\DoxyCodeLine{2979     \}}
\DoxyCodeLine{2980 }
\DoxyCodeLine{2981 }
\DoxyCodeLine{2982     PyObject* line = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2983     PyObject* set\_data\_fct = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{2984 \};}
\DoxyCodeLine{2985 }
\DoxyCodeLine{2986 \} \textcolor{comment}{// end namespace matplotlibcpp}}

\end{DoxyCode}
