\hypertarget{OptimizerFactorized_8h_source}{}\doxysection{Optimizer\+Factorized.\+h}
\label{OptimizerFactorized_8h_source}\index{include/OptimizerFactorized.h@{include/OptimizerFactorized.h}}
\mbox{\hyperlink{OptimizerFactorized_8h}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#ifndef MPVI\_OPTIMIZER\_H}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#define MPVI\_OPTIMIZER\_H}}
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#endif }\textcolor{comment}{//MPVI\_OPTIMIZER\_H}}
\DoxyCodeLine{16 }
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{SparseMatrixHelper_8h}{SparseMatrixHelper.h}}"{}}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{MVGsampler_8h}{MVGsampler.h}}"{}}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <gtsam/base/Matrix.h>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <random>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <utility>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include "{}GaussHermite.h"{}}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{using namespace }GaussianSampler;}
\DoxyCodeLine{26 \textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{27 \textcolor{keyword}{using namespace }Eigen;}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 IOFormat CleanFmt(4, 0, \textcolor{stringliteral}{"{}, "{}}, \textcolor{stringliteral}{"{}\(\backslash\)n"{}});}
\DoxyCodeLine{30 }
\DoxyCodeLine{31 \textcolor{keyword}{namespace}\{}
\DoxyCodeLine{32     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Function, \textcolor{keyword}{typename} costClass, \textcolor{keyword}{typename}... Args>}
\DoxyCodeLine{34 \textcolor{keyword}{class }VIMPOptimizerFactorized\{}
\DoxyCodeLine{35 \textcolor{keyword}{public}:}
\DoxyCodeLine{39     VIMPOptimizerFactorized(\textcolor{keyword}{const} \textcolor{keywordtype}{int}\& dimension, Function \_function, \textcolor{keyword}{const} costClass\& \_cost\_class):}
\DoxyCodeLine{40             dim\_\{dimension\},}
\DoxyCodeLine{41             cost\_function\_\{std::forward<Function>(\_function)\},}
\DoxyCodeLine{42             cost\_class\_\{\_cost\_class\},}
\DoxyCodeLine{43             d\_mu\{VectorXd::Zero(dim\_)\},}
\DoxyCodeLine{44             mu\_\{VectorXd::Zero(dim\_)\},}
\DoxyCodeLine{45             Vdmu\{VectorXd::Zero(dim\_)\},}
\DoxyCodeLine{46             Vddmu\{MatrixXd::Zero(dim\_, dim\_)\},}
\DoxyCodeLine{47             precision\_\{MatrixXd::Identity(dim\_, dim\_)\},}
\DoxyCodeLine{48             d\_precision\{MatrixXd::Zero(dim\_, dim\_)\},}
\DoxyCodeLine{49             covariance\_\{precision\_.inverse()\},}
\DoxyCodeLine{50             sampler\_\{\mbox{\hyperlink{structGaussianSampler_1_1normal__random__variable}{normal\_random\_variable}}(mu\_, precision\_.inverse())\},}
\DoxyCodeLine{51             func\_phi\_\{[\&](const VectorXd\& x)\{\textcolor{keywordflow}{return} MatrixXd\{MatrixXd::Constant(1, 1, cost\_function\_(x, cost\_class\_))\};\}\},}
\DoxyCodeLine{52             gauss\_hermite\_\{10, dim\_, mu\_, covariance\_, func\_phi\_\}\{\}}
\DoxyCodeLine{53 \textcolor{keyword}{protected}:}
\DoxyCodeLine{54     \textcolor{comment}{// optimization variables}}
\DoxyCodeLine{55     \textcolor{keywordtype}{int} dim\_;}
\DoxyCodeLine{56     \textcolor{keywordtype}{int} num\_samples = 50000;}
\DoxyCodeLine{57     VectorXd mu\_, d\_mu;}
\DoxyCodeLine{58     MatrixXd precision\_, d\_precision, covariance\_;}
\DoxyCodeLine{59 }
\DoxyCodeLine{60     VectorXd Vdmu;}
\DoxyCodeLine{61     MatrixXd Vddmu;}
\DoxyCodeLine{62 }
\DoxyCodeLine{64     \textcolor{keywordtype}{double} step\_size\_mu = 0.9;}
\DoxyCodeLine{65     \textcolor{keywordtype}{double} step\_size\_Sigma = 0.9;}
\DoxyCodeLine{66 }
\DoxyCodeLine{68     \mbox{\hyperlink{structGaussianSampler_1_1normal__random__variable}{normal\_random\_variable}} sampler\_;}
\DoxyCodeLine{69 }
\DoxyCodeLine{71     Function cost\_function\_;}
\DoxyCodeLine{72     costClass cost\_class\_;}
\DoxyCodeLine{73 }
\DoxyCodeLine{74     std::function<MatrixXd(\textcolor{keyword}{const} VectorXd\&)> func\_phi\_;}
\DoxyCodeLine{75     GaussHermite<std::function<MatrixXd(\textcolor{keyword}{const} VectorXd\&)>> gauss\_hermite\_;}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{keyword}{public}:}
\DoxyCodeLine{80     \textcolor{keyword}{auto} cost\_function(Args... args)\{}
\DoxyCodeLine{81         \textcolor{keywordflow}{return} cost\_function\_(args..., cost\_class\_);}
\DoxyCodeLine{82     \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{85     \textcolor{keywordtype}{void} set\_step\_size(\textcolor{keywordtype}{double} ss\_mean, \textcolor{keywordtype}{double} ss\_precision)\{}
\DoxyCodeLine{86         step\_size\_mu = ss\_mean;}
\DoxyCodeLine{87         step\_size\_Sigma = ss\_precision;}
\DoxyCodeLine{88     \}}
\DoxyCodeLine{89     }
\DoxyCodeLine{91     \textcolor{keywordtype}{void} updateSamplerCovarianceMatrix(\textcolor{keyword}{const} MatrixXd\& new\_cov)\{}
\DoxyCodeLine{92         sampler\_.updateCovariance(new\_cov);}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{96     \textcolor{keywordtype}{void} updateSamplerCovarianceMatrix()\{}
\DoxyCodeLine{97         sampler\_.updateCovariance(precision\_.inverse());}
\DoxyCodeLine{98     \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100     \textcolor{keywordtype}{void} updateSamplerMean()\{}
\DoxyCodeLine{101         sampler\_.updateMean(mu\_);}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103 }
\DoxyCodeLine{104     \textcolor{keywordtype}{void} updateSamplerMean(\textcolor{keyword}{const} VectorXd\& new\_mu)\{}
\DoxyCodeLine{105         sampler\_.updateMean(new\_mu);}
\DoxyCodeLine{106     \}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108     \textcolor{keywordtype}{void} update\_mu(\textcolor{keyword}{const} VectorXd\& new\_mu)\{}
\DoxyCodeLine{109         mu\_ = new\_mu;}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112     \textcolor{keywordtype}{void} update\_precision(\textcolor{keyword}{const} MatrixXd\& new\_precision)\{}
\DoxyCodeLine{113         precision\_ = new\_precision;}
\DoxyCodeLine{114     \}}
\DoxyCodeLine{115 }
\DoxyCodeLine{116     \textcolor{keywordtype}{void} update\_covariance()\{}
\DoxyCodeLine{117         covariance\_ = precision\_.llt().solve(MatrixXd::Identity(precision\_.rows(), precision\_.cols()));}
\DoxyCodeLine{118 \textcolor{comment}{//        MatrixXd covariance1 = precision\_.inverse();}}
\DoxyCodeLine{119 \textcolor{comment}{//        cout << "{}covariance1 -\/ covariance\_"{} << endl << covariance1 -\/ covariance\_ << endl;}}
\DoxyCodeLine{120     \}}
\DoxyCodeLine{121 }
\DoxyCodeLine{122     \textcolor{keywordtype}{void} updateGH()\{}
\DoxyCodeLine{123         gauss\_hermite\_.update\_mean(mu\_);}
\DoxyCodeLine{124         gauss\_hermite\_.update\_P(covariance\_);}
\DoxyCodeLine{125     \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     \textcolor{keywordtype}{void} calculate\_partial\_V()\{}
\DoxyCodeLine{128         Vdmu.setZero();}
\DoxyCodeLine{129         Vddmu.setZero();}
\DoxyCodeLine{130 }
\DoxyCodeLine{131         MatrixXd samples\{sampler\_(num\_samples)\};}
\DoxyCodeLine{132 }
\DoxyCodeLine{133         \textcolor{keyword}{auto} colwise = samples.colwise();}
\DoxyCodeLine{134         \textcolor{keywordtype}{double} accum\_phi = 0;}
\DoxyCodeLine{135 }
\DoxyCodeLine{136         std::for\_each(colwise.begin(), colwise.end(), [\&](\textcolor{keyword}{auto} \textcolor{keyword}{const} \&sample) \{}
\DoxyCodeLine{137             double phi = cost\_function(sample);}
\DoxyCodeLine{138 \textcolor{comment}{//            double phi = 1;}}
\DoxyCodeLine{139 }
\DoxyCodeLine{140             accum\_phi += phi;}
\DoxyCodeLine{141 }
\DoxyCodeLine{142             Vdmu = Vdmu + (sample -\/ mu\_) * phi;}
\DoxyCodeLine{143             Vddmu = Vddmu + (sample -\/ mu\_) * (sample -\/ mu\_).transpose().eval() * phi;}
\DoxyCodeLine{144         \});}
\DoxyCodeLine{145 }
\DoxyCodeLine{146         update\_covariance();}
\DoxyCodeLine{147         updateGH();}
\DoxyCodeLine{149         std::function<MatrixXd(\textcolor{keyword}{const} VectorXd\&)> func\_Vmu\_ = [\&](\textcolor{keyword}{const} VectorXd\& x)\{\textcolor{keywordflow}{return} MatrixXd\{(x-\/VectorXd\{mu\_\}) * cost\_function\_(x, cost\_class\_)\};\};}
\DoxyCodeLine{150         gauss\_hermite\_.update\_integrand(func\_Vmu\_);}
\DoxyCodeLine{151         MatrixXd Vdmu\_new = gauss\_hermite\_.Integrate();}
\DoxyCodeLine{152         Vdmu\_new = precision\_ * Vdmu\_new;}
\DoxyCodeLine{153 }
\DoxyCodeLine{154         Vdmu = precision\_ * Vdmu.eval() / double(num\_samples);}
\DoxyCodeLine{155 }
\DoxyCodeLine{156         cout << \textcolor{stringliteral}{"{}Vdmu old"{}} << endl << Vdmu << endl;}
\DoxyCodeLine{157         cout << \textcolor{stringliteral}{"{}Vdmu new"{}} << endl << Vdmu\_new << endl;}
\DoxyCodeLine{158 }
\DoxyCodeLine{159         Vddmu.triangularView<Upper>() = (precision\_ * Vddmu * precision\_).triangularView<Upper>();}
\DoxyCodeLine{160         Vddmu.triangularView<StrictlyLower>() = Vddmu.triangularView<StrictlyUpper>().transpose();}
\DoxyCodeLine{161 }
\DoxyCodeLine{162         Vddmu = Vddmu.eval() / double(num\_samples);}
\DoxyCodeLine{163 }
\DoxyCodeLine{165         std::function<MatrixXd(\textcolor{keyword}{const} VectorXd\&)> func\_phi\_ = [\&](\textcolor{keyword}{const} VectorXd\& x)\{\textcolor{keywordflow}{return} MatrixXd\{MatrixXd::Constant(1, 1, cost\_function\_(x, cost\_class\_))\};\};}
\DoxyCodeLine{166         gauss\_hermite\_.update\_integrand(func\_phi\_);}
\DoxyCodeLine{167         \textcolor{keywordtype}{double} avg\_phi = gauss\_hermite\_.Integrate()(0, 0);}
\DoxyCodeLine{168 }
\DoxyCodeLine{169         \textcolor{keywordtype}{double} avg\_phi1 = accum\_phi / double(num\_samples);}
\DoxyCodeLine{170 }
\DoxyCodeLine{171         gtsam::Matrix tmp\{precision\_ * avg\_phi\};}
\DoxyCodeLine{172 }
\DoxyCodeLine{173         Vddmu.triangularView<Upper>() = (Vddmu -\/ precision\_ * avg\_phi).triangularView<Upper>();}
\DoxyCodeLine{174         Vddmu.triangularView<StrictlyLower>() = Vddmu.triangularView<StrictlyUpper>().transpose();}
\DoxyCodeLine{175         cout << \textcolor{stringliteral}{"{}Vddmu "{}} << endl << Vddmu << endl;}
\DoxyCodeLine{176         cout << \textcolor{stringliteral}{"{}avg\_phi"{}} << endl << avg\_phi << endl;}
\DoxyCodeLine{177         cout << \textcolor{stringliteral}{"{}old avg\_phi"{}} << endl << avg\_phi1 << endl;}
\DoxyCodeLine{178 }
\DoxyCodeLine{179     \}}
\DoxyCodeLine{180 }
\DoxyCodeLine{181 }
\DoxyCodeLine{183     \textcolor{keywordtype}{void} calculate\_exact\_partial\_V(VectorXd mu\_t, MatrixXd covariance\_t)\{}
\DoxyCodeLine{184         Vdmu.setZero();}
\DoxyCodeLine{185         Vddmu.setZero();}
\DoxyCodeLine{186         update\_covariance();}
\DoxyCodeLine{187 }
\DoxyCodeLine{188         \textcolor{comment}{// helper vectors}}
\DoxyCodeLine{189         VectorXd eps\{mu\_ -\/ mu\_t\};}
\DoxyCodeLine{190         MatrixXd tmp\{MatrixXd::Zero(dim\_, dim\_)\};}
\DoxyCodeLine{191         MatrixXd precision\_t\{covariance\_t.inverse()\};}
\DoxyCodeLine{192 }
\DoxyCodeLine{193         \textcolor{comment}{// partial V / partial mu}}
\DoxyCodeLine{194         Vdmu = precision\_t * eps;}
\DoxyCodeLine{195 }
\DoxyCodeLine{196         \textcolor{comment}{// partial V\string^2 / partial mu*mu\string^T}}
\DoxyCodeLine{197         \textcolor{comment}{// update tmp matrix}}
\DoxyCodeLine{198         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i=0; i<dim\_; i++)\{}
\DoxyCodeLine{199             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j=0; j<dim\_; j++) \{}
\DoxyCodeLine{200                 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<dim\_; k++)\{}
\DoxyCodeLine{201                     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} l=0; l<dim\_; l++)\{}
\DoxyCodeLine{202                         tmp(i, j) += (covariance\_(i, j)*covariance\_(k, l) + covariance\_(i,k)*covariance\_(j,l) + covariance\_(i,l)*covariance\_(j,k))*precision\_t(k,l);}
\DoxyCodeLine{203                     \}}
\DoxyCodeLine{204                 \}}
\DoxyCodeLine{205             \}}
\DoxyCodeLine{206         \}}
\DoxyCodeLine{207 }
\DoxyCodeLine{208         Vddmu = precision\_ * tmp * precision\_ -\/ precision\_ * (precision\_t*covariance\_).trace();}
\DoxyCodeLine{209         Vddmu = Vddmu / 2;}
\DoxyCodeLine{210 }
\DoxyCodeLine{211         \}}
\DoxyCodeLine{212 }
\DoxyCodeLine{213     MatrixXd get\_Vddmu()\{}
\DoxyCodeLine{214         \textcolor{keywordflow}{return} Vddmu;}
\DoxyCodeLine{215     \}}
\DoxyCodeLine{216 }
\DoxyCodeLine{217     VectorXd get\_Vdmu()\{}
\DoxyCodeLine{218         \textcolor{keywordflow}{return} Vdmu;}
\DoxyCodeLine{219     \}}
\DoxyCodeLine{220 }
\DoxyCodeLine{221     \textcolor{keywordtype}{bool} step()\{}
\DoxyCodeLine{222         \textcolor{comment}{// Zero grad}}
\DoxyCodeLine{223         d\_mu.setZero();}
\DoxyCodeLine{224         d\_precision.setZero();}
\DoxyCodeLine{225 }
\DoxyCodeLine{226         calculate\_partial\_V();}
\DoxyCodeLine{227 \textcolor{comment}{//        calculate\_exact\_partial\_V(cost\_class\_.get\_mean(), cost\_class\_.get\_covariance());}}
\DoxyCodeLine{228 }
\DoxyCodeLine{229         d\_precision = -\/precision\_ + Vddmu;}
\DoxyCodeLine{230 }
\DoxyCodeLine{232         precision\_ = precision\_ + step\_size\_Sigma * d\_precision;}
\DoxyCodeLine{233         d\_mu = precision\_.colPivHouseholderQr().solve(-\/Vdmu);}
\DoxyCodeLine{234 }
\DoxyCodeLine{235         mu\_ = mu\_ + step\_size\_mu * d\_mu;}
\DoxyCodeLine{236 }
\DoxyCodeLine{237         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{238 }
\DoxyCodeLine{240 \textcolor{comment}{//        // last-\/step value cost function evaluation}}
\DoxyCodeLine{241 \textcolor{comment}{//        float l\_V = accum\_phi / num\_samples + log(precision\_.determinant()) / 2.0;}}
\DoxyCodeLine{242 \textcolor{comment}{//        cout << "{}l\_V"{} << l\_V << endl;}}
\DoxyCodeLine{243 \textcolor{comment}{//        MatrixXd l\_precision\_\{precision\_\};}}
\DoxyCodeLine{244 \textcolor{comment}{//        VectorXd l\_mu\{mu\_\};}}
\DoxyCodeLine{245 \textcolor{comment}{//        precision\_.setZero();}}
\DoxyCodeLine{246 \textcolor{comment}{//        mu\_.setZero();}}
\DoxyCodeLine{247 \textcolor{comment}{//        for (int i\_ls=0; i\_ls<10; i\_ls++)\{}}
\DoxyCodeLine{248 \textcolor{comment}{//            B = i\_ls;}}
\DoxyCodeLine{249 \textcolor{comment}{//}}
\DoxyCodeLine{250 \textcolor{comment}{//            precision\_ = l\_precision\_ + pow(step\_size\_Sigma, B) * d\_precision;}}
\DoxyCodeLine{251 \textcolor{comment}{//            d\_mu = precision\_.colPivHouseholderQr().solve(-\/Vdmu);}}
\DoxyCodeLine{252 \textcolor{comment}{//}}
\DoxyCodeLine{253 \textcolor{comment}{//            mu\_ = l\_mu + pow(step\_size\_mu, B) * d\_mu;}}
\DoxyCodeLine{254 \textcolor{comment}{//}}
\DoxyCodeLine{255 \textcolor{comment}{//            // Update the sampler parameters}}
\DoxyCodeLine{256 \textcolor{comment}{//            sampler\_.updateMean(mu\_);}}
\DoxyCodeLine{257 \textcolor{comment}{//            sampler\_.updatePrecisionMatrix(precision\_);}}
\DoxyCodeLine{258 \textcolor{comment}{//}}
\DoxyCodeLine{259 \textcolor{comment}{//            // Evaluate the cost function}}
\DoxyCodeLine{260 \textcolor{comment}{//            gtsam::Matrix samples\_ls\{sampler\_(num\_samples)\};}}
\DoxyCodeLine{261 \textcolor{comment}{//            auto colwise\_ls = samples\_ls.colwise();}}
\DoxyCodeLine{262 \textcolor{comment}{//            double accum\_phi\_ls = 0;}}
\DoxyCodeLine{263 \textcolor{comment}{//            std::for\_each(colwise\_ls.begin(), colwise\_ls.end(), [\&](auto const \&sample) \{}}
\DoxyCodeLine{264 \textcolor{comment}{//                double phi\_ls = cost\_function(sample);}}
\DoxyCodeLine{265 \textcolor{comment}{//                accum\_phi\_ls += phi\_ls;}}
\DoxyCodeLine{266 \textcolor{comment}{//            \});}}
\DoxyCodeLine{267 \textcolor{comment}{//            double new\_V = accum\_phi\_ls/ double(num\_samples) + log(precision\_.determinant())/2.0;}}
\DoxyCodeLine{268 \textcolor{comment}{//}}
\DoxyCodeLine{269 \textcolor{comment}{//            if (new\_V < l\_V)\{}}
\DoxyCodeLine{270 \textcolor{comment}{//                cout << "{}Lower value function"{} << endl << "{}precision\_ "{} << endl << precision\_.format(CleanFmt) << endl;}}
\DoxyCodeLine{271 \textcolor{comment}{//                return true;}}
\DoxyCodeLine{272 \textcolor{comment}{//            \}}}
\DoxyCodeLine{273 \textcolor{comment}{//}}
\DoxyCodeLine{274 \textcolor{comment}{//            if (isnan(new\_V))\{}}
\DoxyCodeLine{275 \textcolor{comment}{//                cout << "{}nan new cost function"{} << endl << "{}precision matrix"{} << endl}}
\DoxyCodeLine{276 \textcolor{comment}{//                     << precision\_.format(CleanFmt) << endl << "{}determinate"{} << precision\_.determinant() << endl;}}
\DoxyCodeLine{277 \textcolor{comment}{//                break;}}
\DoxyCodeLine{278 \textcolor{comment}{//            \}}}
\DoxyCodeLine{279 \textcolor{comment}{//        \}}}
\DoxyCodeLine{280 }
\DoxyCodeLine{281 \textcolor{comment}{//        // Update the sampler parameters}}
\DoxyCodeLine{282 \textcolor{comment}{//        sampler\_.updateMean(l\_mu);}}
\DoxyCodeLine{283 \textcolor{comment}{//        sampler\_.updatePrecisionMatrix(l\_precision\_);}}
\DoxyCodeLine{284 }
\DoxyCodeLine{285 \textcolor{comment}{//        cout << "{}no lower value function"{} << endl << "{}precision\_ "{} << endl << precision\_.format(CleanFmt) << endl;}}
\DoxyCodeLine{286 \textcolor{comment}{//        return false;}}
\DoxyCodeLine{287 }
\DoxyCodeLine{288     \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290     VectorXd get\_mean()\{}
\DoxyCodeLine{291         \textcolor{keywordflow}{return} mu\_;}
\DoxyCodeLine{292     \}}
\DoxyCodeLine{293 }
\DoxyCodeLine{294     MatrixXd get\_precision()\{}
\DoxyCodeLine{295         \textcolor{keywordflow}{return} precision\_;}
\DoxyCodeLine{296     \}}
\DoxyCodeLine{297 }
\DoxyCodeLine{298     MatrixXd get\_covariance()\{}
\DoxyCodeLine{299         \textcolor{keywordflow}{return} precision\_.inverse();}
\DoxyCodeLine{300     \}}
\DoxyCodeLine{301 }
\DoxyCodeLine{302 \};}
\DoxyCodeLine{303 }
\DoxyCodeLine{304 \}}

\end{DoxyCode}
